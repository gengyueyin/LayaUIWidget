var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/*
 * @Author: devilsome.曾挚
 * @Date: 2017-02-09 22:07:27
 * @Last Modified by: wesai.谢久伟
 * @Last Modified time: 2017-11-28 17:37:02
 *
 * 游戏中网络消息处理中枢
 */
var wesai;
(function (wesai) {
    var HoldemPoker;
    (function (HoldemPoker) {
        var Resource;
        (function (Resource) {
            Resource.protos = {
                hosts: { url: "cfgs/connection.json", type: Laya.Loader.JSON },
                // errorProto: { url: "proto/error.proto", type: Laya.Loader.TEXT, buildName: "error" },
                // clubProto: { url: "proto/club.proto", type: Laya.Loader.TEXT, buildName: "club" },
                // chatProto: { url: "proto/chat.proto", type: Laya.Loader.TEXT, buildName: "chat" },
                // pokerProto: { url: "proto/poker.proto", type: Laya.Loader.TEXT, buildName: "poker" },
                // raceProto: { url: "proto/race.proto", type: Laya.Loader.TEXT, buildName: "race" },
                // notifyProto: { url: "proto/notify.proto", type: Laya.Loader.TEXT, buildName: "notify" },
                // voiceProto: { url: "proto/voice.proto", type: Laya.Loader.TEXT, buildName: "voice" },
                // mallProto: { url: "proto/mall.proto", type: Laya.Loader.TEXT, buildName: "mall" }
                main: { url: "proto/main.proto", type: Laya.Loader.TEXT }
            };
        })(Resource = HoldemPoker.Resource || (HoldemPoker.Resource = {}));
        var NetworkMgr = /** @class */ (function (_super) {
            __extends(NetworkMgr, _super);
            function NetworkMgr() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.connectCfg = {
                    "srv_ip": "211.159.155.205",
                    "srv_port": 9555,
                    "timeout": 10000,
                    "ping": 5000
                };
                //确认只抛出一个错误
                _this.error = false;
                _this.msgTimeout = 5000;
                _this.pingTime = 5000;
                _this.signalStatus = 4;
                _this.resetMsgTimeout = false;
                // NetworkMgr.connected不可靠，再加个确认连接
                _this._insureConnected = false;
                return _this;
            }
            NetworkMgr.prototype.Initalize = function () {
                this.curIP = null;
                this.ping = 0;
                this.msgHandlerMap = new Laya.Dictionary;
                this.socket = new HoldemPoker.WebSocket;
                this.registerSocketEvent();
                this.notifyMap = {};
                this.errorMap = {};
                HoldemPoker.Sys.event.on(HoldemPoker.GEvent.ON_APP_RESUME, this, this.onCheckNet);
                //注册一个通用的错误提示
                this.registerErrorMsg(HoldemPoker.msg.Codes.Error, this, this.onCommonError);
            };
            NetworkMgr.prototype.Dispose = function () {
                this.unregisterAllMap();
                this.unregisterSocketEvent();
                Laya.timer.clearAll(this);
                this.closeSocket();
                this.socket.destory();
                HoldemPoker.Sys.event.off(HoldemPoker.GEvent.ON_APP_RESUME, this, this.onCheckNet);
                //this.socket.close();
                //this.socket = null;
            };
            NetworkMgr.prototype.unregisterAllMap = function () {
                for (var notify in this.notifyMap) {
                    var handler = this.notifyMap[notify];
                    if (handler) {
                        handler.recover();
                    }
                }
                for (var err in this.errorMap) {
                    var handler = this.errorMap[err];
                    if (handler) {
                        handler.recover();
                    }
                }
                for (var msg in this.msgHandlerMap.values) {
                    var handler = this.msgHandlerMap[msg];
                    if (handler) {
                        handler.recover();
                    }
                }
                this.notifyMap = {};
                this.errorMap = {};
                this.protoRoot = new protobuf.Root();
                this.msgHandlerMap.clear();
                HoldemPoker.Sys.event.off(HoldemPoker.GEvent.ON_APP_RESUME, this, this.onCheckNet);
            };
            NetworkMgr.prototype.onCommonError = function (data) {
                HoldemPoker.MessageDialog.showWithText(HoldemPoker.Utility.toMessageWithCode(data.codes));
            };
            Object.defineProperty(NetworkMgr.prototype, "connected", {
                get: function () {
                    if (this.socket !== null) {
                        return this.socket.connected;
                    }
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(NetworkMgr.prototype, "insureConnected", {
                get: function () {
                    if (this.socket && this.socket.connected === false) {
                        return false;
                    }
                    else {
                        return this._insureConnected;
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
             * 配置加载完成后，通过配置连接
             * @memberOf NetworkMgr
             */
            NetworkMgr.prototype.LoadFromRes = function () {
                var cfg = HoldemPoker.Sys.loader.getRes(Resource.protos.hosts.url);
                console.debug("[" + this.constructor.name + "]Loaded server config: " + JSON.stringify(cfg));
                if (cfg.default !== undefined) {
                    this.connectCfg = cfg.default;
                }
                this.msgTimeout = this.connectCfg.timeout;
                this.pingTime = this.connectCfg.ping;
                this.protoRoot = new protobuf.Root();
                //使用取laya缓存里的
                this.protoRoot = protobuf.parse(Laya.loader.getRes(Resource.protos.main.url)).root;
            };
            NetworkMgr.prototype.getIP = function (isTest) {
                return __awaiter(this, void 0, void 0, function () {
                    var secretKey, encryptData, ip, e_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (isTest) {
                                    return [2 /*return*/, null]; //平时调试用
                                }
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, , 4]);
                                HoldemPoker.BenchmarkHelper.time('getSafeIp');
                                secretKey = HoldemPoker.SafeIpUtil.getSecretKey();
                                encryptData = HoldemPoker.SafeIpUtil.encrypt(JSON.stringify({
                                    available: true,
                                    user_age: 1 * 60 * 60 * 1000,
                                    num: 1,
                                }), secretKey);
                                return [4 /*yield*/, HoldemPoker.SafeIpUtil.getIP(HoldemPoker.SafeIpUtil.buildUrl(), encryptData, secretKey)];
                            case 2:
                                ip = _a.sent();
                                console.log('拿到的ip' + ip);
                                HoldemPoker.BenchmarkHelper.timeEnd('getSafeIp');
                                return [2 /*return*/, ip]; //正式用
                            case 3:
                                e_1 = _a.sent();
                                console.log(e_1);
                                return [2 /*return*/, null];
                            case 4: return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * 登录到游戏主服务器
             * @memberOf NetworkMgr
             */
            NetworkMgr.prototype.connectServer = function (ip, port) {
                var _this = this;
                HoldemPoker.Sys.net.event(HoldemPoker.GEvent.NET_RECON);
                //注册超时定时器
                this.startConnectTimeoutTimer();
                var isTest = !HoldemPoker.ReleaseInfo.safeIp; //发版改这个
                // let isTest = true;
                this.getIP(isTest).then(function (flag) {
                    if (flag) {
                        _this.curIP = flag;
                    }
                    else {
                        _this.curIP = ip;
                    }
                    _this.curPort = port;
                    _this.connect();
                    console.debug("@@@@@ [" + _this.constructor.name + "]connecting to " + _this.curIP + ":" + _this.curPort);
                });
            };
            NetworkMgr.prototype.connectServerByName = function (srv, ip, port) {
                var cfg = HoldemPoker.Sys.loader.getRes(Resource.protos.hosts.url);
                this.connectCfg = (srv && cfg[srv]) ? cfg[srv] : this.connectCfg;
                if (ip) {
                    this.connectCfg.srv_ip = ip;
                }
                if (port) {
                    this.connectCfg.srv_port = port;
                }
                this.msgTimeout = this.connectCfg.timeout;
                this.pingTime = this.connectCfg.ping;
                this.curIP = this.connectCfg.srv_ip;
                this.curPort = this.connectCfg.srv_port;
                this.connectServer(this.curIP, this.curPort);
            };
            /**
             * 注册广播消息回调
             *
             * @param {string} msgName
             * @param {Laya.Handler} handler
             *
             * @memberOf NetworkMgr
             */
            NetworkMgr.prototype.registerNotifyMsg = function (msgName, caller, callback) {
                var handler = Laya.Handler.create(caller, callback, null, false);
                var value = this.notifyMap[msgName];
                if (value === null ||
                    value === undefined) {
                    this.notifyMap[msgName] = handler;
                }
                else {
                    console.warn("[" + this.constructor.name + "] registerNotifyMsg: register notify msg[" + msgName + "] has already been registered.");
                    value.recover();
                    this.notifyMap[msgName] = handler;
                }
            };
            /**
             * 注册错误消息处理回调
             * @param id 错误消息id
             * @param caller
             * @param callback
             */
            NetworkMgr.prototype.registerErrorMsg = function (id, caller, callback, args) {
                var handler = Laya.Handler.create(caller, callback, args, false);
                var value = this.errorMap[id];
                if (value === null ||
                    value === undefined) {
                    this.errorMap[id] = handler;
                }
                else {
                    console.warn("[" + this.constructor.name + "] registerErrorMsg: register error msg[" + id + "] has already been registered.");
                    value.recover();
                    this.errorMap[id] = handler;
                }
            };
            /**
             * 取消广播消息回调
             *
             * @param {string} msgName
             *
             * @memberOf NetworkMgr
             */
            NetworkMgr.prototype.unRegisterNotifyMsg = function (msgName) {
                var handler = this.notifyMap[msgName];
                if (handler) {
                    handler.recover();
                    handler = null;
                }
                this.notifyMap[msgName] = null;
            };
            NetworkMgr.prototype.unRegisterErrorMsg = function (id) {
                var handler = this.errorMap[id];
                if (handler) {
                    handler.recover();
                    handler = null;
                }
                this.errorMap[id] = null;
            };
            NetworkMgr.prototype.closeSocket = function () {
                this.stopHeartBeat();
                this.stopConnectTimeoutTimer();
                this.stopMsgTimeoutTimer();
                this._insureConnected = null;
                this.socket.close();
            };
            NetworkMgr.prototype.connect = function () {
                HoldemPoker.BenchmarkHelper.time('connectMainServer');
                this.error = false;
                this.socket.connect(this.curIP, this.curPort, this.msgTimeout);
            };
            NetworkMgr.prototype.registerSocketEvent = function () {
                this.socket.on(HoldemPoker.WebSocket.CONNECT_SUCCESS, this, this.onConnected);
                this.socket.on(HoldemPoker.WebSocket.CONNECT_ERROR, this, this.onConnectError);
                this.socket.on(HoldemPoker.WebSocket.CONNECT_CLOSE, this, this.onConnectClose);
                this.socket.on(HoldemPoker.WebSocket.RECEIVE_DATA, this, this.onReceiveData);
                this.on(HoldemPoker.GEvent.CONNECT_CLOSE, this, this.updateNetStatus);
                this.on(HoldemPoker.GEvent.CONNECT_ERROR, this, this.updateNetStatus);
            };
            NetworkMgr.prototype.unregisterSocketEvent = function () {
                this.socket.off(HoldemPoker.WebSocket.CONNECT_SUCCESS, this, this.onConnected);
                this.socket.off(HoldemPoker.WebSocket.CONNECT_ERROR, this, this.onConnectError);
                this.socket.off(HoldemPoker.WebSocket.CONNECT_CLOSE, this, this.onConnectClose);
                this.socket.off(HoldemPoker.WebSocket.RECEIVE_DATA, this, this.onReceiveData);
                this.off(HoldemPoker.GEvent.CONNECT_CLOSE, this, this.updateNetStatus);
                this.off(HoldemPoker.GEvent.CONNECT_ERROR, this, this.updateNetStatus);
            };
            NetworkMgr.prototype.startConnectTimeoutTimer = function () {
                Laya.timer.once(this.msgTimeout, this, this.onConnectTimeout);
            };
            NetworkMgr.prototype.stopConnectTimeoutTimer = function () {
                Laya.timer.clear(this, this.onConnectTimeout);
            };
            NetworkMgr.prototype.startMsgTimeoutTimer = function (coverBefore) {
                Laya.timer.once(this.msgTimeout, this, this.onMsgTimeout, null, coverBefore);
            };
            NetworkMgr.prototype.stopMsgTimeoutTimer = function () {
                Laya.timer.clear(this, this.onMsgTimeout);
            };
            NetworkMgr.prototype.onConnected = function () {
                // 移除超时定时器
                HoldemPoker.Sys.net.event(HoldemPoker.GEvent.NET_OK);
                this.stopConnectTimeoutTimer();
                this.resetMsgTimeout = false;
                this._insureConnected = true;
                this.event(HoldemPoker.GEvent.CONNECT_OK);
                console.debug("[" + this.constructor.name + "] connected.");
                HoldemPoker.BenchmarkHelper.timeEnd('connectMainServer');
            };
            NetworkMgr.prototype.onConnectError = function () {
                if (this.error) {
                    return;
                }
                this.error = true;
                HoldemPoker.MessageDialog.showWithText(HoldemPoker.Sys.localization.get(HoldemPoker.stringtable.connectFail));
                //当连接出错，停止心跳包
                HoldemPoker.Sys.ui.stopLoading();
                this.stopHeartBeat();
                this.stopConnectTimeoutTimer();
                this.stopMsgTimeoutTimer();
                this._insureConnected = false;
                this.event(HoldemPoker.GEvent.CONNECT_ERROR);
                HoldemPoker.Sys.net.event(HoldemPoker.GEvent.NET_RECONNECT_SUCCESS);
                console.debug("[" + this.constructor.name + "] connect error.");
            };
            NetworkMgr.prototype.onConnectClose = function () {
                if (this.error) {
                    return;
                }
                this.error = true;
                this.stopHeartBeat();
                this.stopConnectTimeoutTimer();
                this.stopMsgTimeoutTimer();
                this._insureConnected = false;
                this.event(HoldemPoker.GEvent.CONNECT_ERROR);
                this.event(HoldemPoker.GEvent.CONNECT_CLOSE);
                console.debug("[" + this.constructor.name + "] connect closed");
            };
            NetworkMgr.prototype.stopHeartBeat = function () {
                Laya.timer.clear(this, this.sendHeartBeat);
                this.curSendTime = 0;
            };
            NetworkMgr.prototype.onConnectTimeout = function () {
                console.debug("[" + this.constructor.name + "] connect timeout.");
                this.closeSocket();
            };
            NetworkMgr.prototype.onMsgTimeout = function () {
                HoldemPoker.Sys.net.event(HoldemPoker.GEvent.NET_ERR);
                console.debug("[" + this.constructor.name + "] send message timeout.");
                this._insureConnected = false;
                this.event(HoldemPoker.GEvent.CONNECT_ERROR);
                this.closeSocket();
            };
            /**
             * 用该方法发送消息，一定有回包
             *
             * @param {string} msgName
             * @param {*} data
             * @param {Laya.Handler} receiveHandler
             * @param {Laya.Handler} [errorHandler]
             *
             * @memberOf NetworkMgr
             */
            NetworkMgr.prototype.sendMesage = function (msgName, data, receiveHandler, errorHandler) {
                if (!this._insureConnected) {
                    console.warn("!!!!!! [" + this.constructor.name + "] sendMesage [" + msgName + "]: network hasn't been connected.");
                    this.event(HoldemPoker.GEvent.CONNECT_ERROR);
                    return;
                }
                // let messageProto: protobuf.Type = this.protoRoot.lookupType(msgName);
                var messageProto;
                try {
                    messageProto = this.protoRoot.lookupType(msgName);
                }
                catch (e) {
                    console.error("[" + this.constructor.name + "] msgName======[" + msgName + "]======not found");
                    throw new Error(e);
                }
                if (messageProto) {
                    var instance = messageProto.create(data);
                    var buf = messageProto.encode(instance).finish();
                    this.msgHandlerMap.set(this.socket.seq, [receiveHandler, errorHandler]);
                    console.log("[" + this.constructor.name + "]send msg:(" + this.socket.seq + ") " + msgName + ": " + JSON.stringify(data));
                    this.socket.sendMessage(msgName, buf);
                    if (!this.resetMsgTimeout) {
                        this.resetMsgTimeout = true;
                        this.startMsgTimeoutTimer(true);
                    }
                }
                else {
                    console.error("[" + this.constructor.name + "][ERROR]send: can not find message: " + msgName);
                }
            };
            NetworkMgr.prototype.requestNotify = function (msgName, data) {
                if (!this._insureConnected) {
                    console.warn("!!!!!! [" + this.constructor.name + "]requestNotify [" + msgName + "]: network hasn't been connected.");
                    this.event(HoldemPoker.GEvent.CONNECT_ERROR);
                    return;
                }
                // let messageProto: protobuf.Type = this.protoRoot.lookupType(msgName);
                var messageProto;
                try {
                    messageProto = this.protoRoot.lookupType(msgName);
                }
                catch (e) {
                    console.error("[" + this.constructor.name + "] msgName======[" + msgName + "]======not found");
                    throw new Error(e);
                }
                if (messageProto) {
                    var instance = messageProto.create(data);
                    var buf = messageProto.encode(instance).finish();
                    console.log("[" + this.constructor.name + "]send requestNotify: (" + this.socket.seq + ") " + msgName + ": " + JSON.stringify(data));
                    HoldemPoker.NativeModule.saveLog("[" + this.constructor.name + "]send requestNotify: (" + this.socket.seq + ") " + msgName + ": " + JSON.stringify(data));
                    this.socket.sendMessage(msgName, buf);
                    if (!this.resetMsgTimeout) {
                        this.resetMsgTimeout = true;
                        this.startMsgTimeoutTimer(true);
                    }
                }
                else {
                    console.error("[" + this.constructor.name + "][ERROR]send: can not find message: " + msgName);
                }
            };
            NetworkMgr.prototype.sendHeartBeat = function () {
                if (!this._insureConnected) {
                    // console.warn(">>>>> send heartbeat: network hasn't been connected.");
                    // this.event(GEvent.CONNECT_ERROR);
                    return;
                }
                var heartBeat = "HeartbeatRequest";
                var messageProto = this.protoRoot.lookupType(heartBeat);
                if (messageProto) {
                    // var instance = new pkg();
                    var instance = messageProto.create();
                    var buf = messageProto.encode(instance).finish();
                    this.socket.sendMessage(heartBeat, buf);
                    this.curSendTime = Laya.timer.currTimer;
                    if (!this.resetMsgTimeout) {
                        this.resetMsgTimeout = true;
                        this.startMsgTimeoutTimer(true);
                    }
                }
                else {
                    console.error("[ERROR][" + this.constructor.name + "]send: can not find message: hearbeat");
                }
            };
            NetworkMgr.prototype.onReceiveHeartBeat = function () {
                this.ping = Laya.timer.currTimer - this.curSendTime;
                if (this.ping < 200) {
                    this.event(HoldemPoker.GEvent.CONNECT_SIGNAL_WEAK);
                    this.signalStatus = 4;
                }
                else if (this.ping < 400) {
                    this.signalStatus = 3;
                }
                else if (this.ping < 1000) {
                    this.signalStatus = 2;
                }
                else if (this.ping >= 2000 && this.ping < 4000) {
                    this.signalStatus = 1;
                    // this.ping = 2000;
                    this.event(HoldemPoker.GEvent.CONNECT_SIGNAL_WEAK);
                }
                else {
                    this.signalStatus = 0;
                }
                // console.log(`.....ping: ${this.ping}ms`);
            };
            NetworkMgr.prototype.onReceiveData = function (msgName, seq, data) {
                if (!this.socket.connected) {
                    console.warn(">>>>> [" + this.constructor.name + "] receive message: network hasn't been connected.");
                    this.event(HoldemPoker.GEvent.CONNECT_ERROR);
                    return;
                }
                //只要收到消息，就重置定时器
                this.resetMsgTimeout = false;
                this.stopMsgTimeoutTimer();
                var messageProto;
                try {
                    messageProto = this.protoRoot.lookupType(msgName);
                }
                catch (e) {
                    console.error("[" + this.constructor.name + "] msgName======[" + msgName + "] seq[" + seq + "]======not found");
                    throw new Error(e);
                }
                if (messageProto) {
                    var msg_1 = messageProto.decode(new Uint8Array(data));
                    if (msgName !== "HeartbeatResponse") {
                        console.log("[" + this.constructor.name + "] receive message:(" + seq + ") " + msgName + " " + JSON.stringify(msg_1));
                        HoldemPoker.NativeModule.saveLog("[" + this.constructor.name + "] receive message:(" + seq + ") " + msgName + " " + JSON.stringify(msg_1));
                    }
                    if (msg_1) {
                        var msgHandler = null;
                        var errorHandler = null;
                        var handler = this.msgHandlerMap.get(seq);
                        if (handler) {
                            msgHandler = handler[0];
                            errorHandler = handler[1];
                            this.msgHandlerMap.remove(seq);
                        }
                        if (msgName === "ErrorMsg") {
                            var errorMsg = msg_1;
                            if (errorHandler) {
                                errorHandler.runWith(errorMsg);
                            }
                            else {
                                if (this.errorMap[errorMsg.codes] !== null && this.errorMap[errorMsg.codes] !== undefined) {
                                    this.errorMap[errorMsg.codes].runWith(msg_1);
                                }
                                else {
                                    this.onCommonError(errorMsg);
                                    console.error("[" + this.constructor.name + "] receive server unknown error:" + JSON.stringify(errorMsg));
                                }
                            }
                        }
                        else if (msgName === "HeartbeatResponse") {
                            if (!HoldemPoker.Sys.mistiming || HoldemPoker.Sys.mistiming === 0) {
                                //计算和服务器的时间差
                                var heart = msg_1;
                                var da = new Date();
                                var myTime = da.getTime();
                                console.log(heart.timestamp + " --- " + (heart.timestamp - myTime));
                                HoldemPoker.Sys.mistiming = heart.timestamp - myTime;
                            }
                            this.onReceiveHeartBeat();
                        }
                        else if (this.notifyMap[msgName] !== null && this.notifyMap[msgName] !== undefined) {
                            this.notifyMap[msgName].runWith(msg_1);
                        }
                        else {
                            if (msgHandler) {
                                msgHandler.runWith(msg_1);
                            }
                        }
                        errorHandler = null;
                        msgHandler = null;
                    }
                    else {
                        console.error("[ERROR][" + this.constructor.name + "]can not decode message:(" + seq + ") " + msgName);
                    }
                }
                else {
                    console.error("[ERROR][" + this.constructor.name + "] can not find message body: " + msgName);
                }
            };
            /**
             * 后台回来专用，触发重连
             */
            NetworkMgr.prototype.onCheckNet = function () {
                this.event(HoldemPoker.GEvent.CONNECT_ERROR);
            };
            NetworkMgr.prototype.startHearbeat = function () {
                Laya.timer.loop(this.pingTime, this, this.sendHeartBeat);
            };
            NetworkMgr.prototype.updateNetStatus = function (status) {
                if (status === void 0) { status = 0; }
                this.signalStatus = status;
            };
            return NetworkMgr;
        }(Laya.EventDispatcher));
        HoldemPoker.NetworkMgr = NetworkMgr;
    })(HoldemPoker = wesai.HoldemPoker || (wesai.HoldemPoker = {}));
})(wesai || (wesai = {}));
//# sourceMappingURL=NetworkMgr.js.map