var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/*
 * @Author: wesai.谢久伟
 * @Date: 2017-06-14 10:30:42
 * @Last Modified by: wesai.谢久伟
 * @Last Modified time: 2017-12-22 20:16:33
 */
var wesai;
(function (wesai) {
    var HoldemPoker;
    (function (HoldemPoker) {
        //通过Resourc命名空间来导出每个模块需要用的资源
        var Resource;
        (function (Resource) {
            Resource.panelUI = {
                actionState: { url: "res/atlas/1334/actionstate.atlas", type: Laya.Loader.ATLAS },
                enActionState: { url: "res/atlas/1334/actionstate/EN.atlas", type: Laya.Loader.ATLAS },
                simpleActionState: { url: "res/atlas/1334/actionstate/simple.atlas", type: Laya.Loader.ATLAS },
                dragonPlayerState: { url: "res/atlas/1334/playerState.atlas" },
                dragonPlayerStateSk: { url: "1334/playerState/dragon_action_state.sk", type: Laya.Loader.BUFFER },
                action: { url: "Animation/playerAction.ani", type: Laya.Loader.JSON },
            };
        })(Resource = HoldemPoker.Resource || (HoldemPoker.Resource = {}));
        var PlayerPanelUI = /** @class */ (function (_super) {
            __extends(PlayerPanelUI, _super);
            function PlayerPanelUI(panelCount) {
                var _this = _super.call(this) || this;
                //筹码在右边 筹码在左边
                //public betTextPosition = [[32, 5], [-64, 5]];
                _this.loopSpeed = 1;
                _this.componentPosition = [
                    [
                        [10 + 19, -41 + 19],
                        [62 + 17, -40 + 17],
                        [32, -2, 0],
                        [94, 73],
                        [144, 32],
                        [5, 5],
                    ],
                    [
                        [125 + 19, 167 + 19],
                        [128 + 17, 125 + 17],
                        [32, -2, 0],
                        [94, 73],
                        [32, 128],
                        [5, 5],
                    ],
                    [
                        [136 + 19, 86 + 19],
                        [95 + 17, 135 + 17],
                        [32, -2, 0],
                        [94, 73],
                        [-80, 32],
                        [5, 5],
                    ],
                    [
                        [10 + 19, 135 + 19],
                        [64 + 17, 138 + 17],
                        [32, -2, 0],
                        [94, 73],
                        [144, 32],
                        [5, 5],
                    ],
                    [
                        [-22 + 19, 86 + 19],
                        [24 + 17, 135 + 17],
                        [32, -2, 0],
                        [20, 73],
                        [144, 32],
                        [77, 5],
                    ],
                    [
                        [-12 + 19, 167 + 19],
                        [-9 + 17, 125 + 17],
                        [-73, -2, 1],
                        [20, 73],
                        [32, 128],
                        [77, 5],
                    ],
                    [
                        [10 + 19, -41 + 19],
                        [62 + 17, -40 + 17],
                        [32, -2, 0],
                        [94, 73],
                        [-157, 70],
                        [5, 5],
                    ],
                ];
                _this.panelPosIdx = [
                    [0, 3],
                    [0, 1, 5],
                    [0, 1, 3, 5],
                    [0, 1, 1, 5, 5],
                    [0, 1, 1, 3, 5, 5],
                    [0, 1, 1, 2, 4, 5, 5],
                    [0, 1, 1, 1, 3, 5, 5, 5],
                    [0, 1, 1, 1, 2, 4, 5, 5, 5]
                ];
                _this.voiceAnimation = null;
                _this.isLeftPlay = false;
                _this.isRightPlay = false;
                _this.aniRaio = 15;
                _this.onLanguageChanged();
                _this.maxPanelCount = panelCount;
                return _this;
            }
            Object.defineProperty(PlayerPanelUI.prototype, "clientPos", {
                get: function () {
                    return this.clientpos;
                },
                set: function (val) {
                    if (val >= 0) {
                        this.clientpos = val;
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
             *
             * 创建界面
             * 主要是创建对象
             *
             * @memberOf RegisterUIEvent
             */
            PlayerPanelUI.prototype.Initalize = function () {
                this.initDragon();
                this.showActionDelay = HoldemPoker.Sys.gameCfg["PlayerPanelUI.showActionDelay"] ? HoldemPoker.Sys.gameCfg["PlayerPanelUI.showActionDelay"] : 1000;
                this.currentBet = 0;
                this.RegisterUIEvent();
                this.Refresh();
                //界面初始化
                this.updateBySeat(null);
                this.clientpos = this.serverPos;
                this.visible = true;
                this.showCardBgLeft.skin = HoldemPoker.Utility.getCardBackSkin();
                this.showCardBgRight.skin = HoldemPoker.Utility.getCardBackSkin();
            };
            PlayerPanelUI.prototype.initDragon = function () {
                this.dragonPlayerStateAni = new HoldemPoker.DragonAni("1334/playerState/dragon_action_state.sk", this);
            };
            PlayerPanelUI.prototype.stateAnimPlay = function () {
                if (this.dragonPlayerStateAni.aniEnable) {
                    this.dragonPlayerStateAni.visible = true;
                    // this.dragonPlayerStateAni.mArmature.playbackRate(0.1);
                    this.dragonPlayerStateAni.play(0, false, true);
                    return true;
                }
                return false;
            };
            //#############骨骼动画##################
            PlayerPanelUI.prototype.RegisterUIEvent = function () {
                this.seatBtn.on(Laya.Event.CLICK, this, this.onSitSeat);
                this.player.on(Laya.Event.CLICK, this, this.onShowPlayerInfo);
                HoldemPoker.Sys.net.on(HoldemPoker.GEvent.CHANGE_CARD_SKIN, this, this.updateCardSkin);
                // Sys.net.on(GEvent.QUICK_CHAT_NOTIFY, this, this.showQuickChat);
            };
            PlayerPanelUI.prototype.UnregisterUIEvent = function () {
                this.seatBtn.off(Laya.Event.CLICK, this, this.onSitSeat);
                this.player.off(Laya.Event.CLICK, this, this.onShowPlayerInfo);
                HoldemPoker.Sys.net.off(HoldemPoker.GEvent.CHANGE_CARD_SKIN, this, this.updateCardSkin);
                // Sys.net.off(GEvent.QUICK_CHAT_NOTIFY, this, this.showQuickChat);
            };
            PlayerPanelUI.prototype.onLanguageChanged = function () {
                this.seatBtn.skin = HoldemPoker.Sys.localization.getResDir("1334/ingame/", "Avatar_null.png");
            };
            PlayerPanelUI.prototype.onTableTypeChange = function () {
                this.playState.skin = HoldemPoker.Utility.setSimple(HoldemPoker.Sys.isSimple, this.playState.skin);
                this.imgDeal.skin = HoldemPoker.Utility.setSimple(HoldemPoker.Sys.isSimple, this.imgDeal.skin);
            };
            /**
             *
             * 刷新界面，坐标，长宽和图片啥的
             * 比如横屏竖屏切换，刷新语言啥的
             *
             * @abstract
             *
             * @memberOf LoginUI
             */
            PlayerPanelUI.prototype.Refresh = function () {
            };
            /**
             *
             * 销毁界面
             *
             * @memberOf LoginUI
             */
            PlayerPanelUI.prototype.Dispose = function () {
                // this.ani_Allin.stop();
                this.ani_PictureNum.stop();
                this.dragonPlayerStateAni.stop();
                this.flashPointAni.stop();
                this.countDownMask.graphics.clear();
                this.UnregisterUIEvent();
                HoldemPoker.Sys.ui.remove(this);
                this.offAll();
                this.destroy();
            };
            /**
             * 托管
             */
            PlayerPanelUI.prototype.updateManaged = function (seat) {
                if (this.player) {
                    if (seat) {
                        if (!this.trusteshipLabel) {
                            this.trusteshipLabel = new Laya.Image();
                            this.trusteshipLabel.skin = HoldemPoker.Sys.localization.getResDir("1334/ingame/", "control.png");
                            this.trusteshipLabel.scaleX = 1.6;
                            this.trusteshipLabel.scaleY = 1.6;
                            this.player.avatarImg.addChild(this.trusteshipLabel);
                            this.trusteshipLabel.pivot(this.trusteshipLabel.width / 2, this.trusteshipLabel.height / 2);
                            this.trusteshipLabel.pos(this.player.avatarImg.width / 2, this.player.avatarImg.height / 2);
                        }
                        if (this.trusteshipLabel) {
                            //如果有排名 就不能显示托管标志
                            if (seat.state === HoldemPoker.msg.EPlayerState.sngover && seat.rank > 0) {
                                this.trusteshipLabel.visible = false;
                            }
                            else {
                                this.trusteshipLabel.visible = seat.managed;
                            }
                        }
                        this.player.avatarImg.alpha = 1;
                        //头像
                        HoldemPoker.Utility.loadImg(this.player.avatarImg, HoldemPoker.GPLAYER_DEFAULT_ICON, seat.playerIcon);
                    }
                    else {
                        if (this.trusteshipLabel) {
                            this.trusteshipLabel.visible = false;
                        }
                    }
                }
            };
            PlayerPanelUI.prototype.setSngRankGray = function () {
                this.player.filters = [HoldemPoker.Utility.grayFilter()];
                this.chipTextBg.filters = [HoldemPoker.Utility.grayFilter()];
            };
            PlayerPanelUI.prototype.setSNGRankLabel = function (seat) {
                if (seat && seat.rank > 0 && seat.state === HoldemPoker.msg.EPlayerState.sngover) {
                    if (this.rankLabel.visible === false) {
                        this.rankLabel.visible = true;
                        this.rankImgBg.visible = true;
                        this.rankLabel.text = HoldemPoker.Sys.localization.getFormated(HoldemPoker.stringtable.rank, seat.rank);
                        this.rankBox.filters = [];
                        this.setSngRankGray();
                    }
                    //有名次 就不显示 托管中
                    seat.managed = false;
                    this.updateManaged(seat);
                    return;
                }
                this.rankImgBg.visible = false;
                this.rankLabel.visible = false;
            };
            PlayerPanelUI.prototype.showdown = function (visible) {
                this.showDown.visible = visible; // 摊牌阶段显示为假
                this.winner.visible = false;
                this.imgBoardCard0.visible = visible;
                this.imgBoardCard1.visible = visible;
                this.showCardAniLeft.stop();
                this.showCardAniLeft.resetToInitState();
                this.showCardAniRight.stop();
                this.showCardAniRight.resetToInitState();
                this.showCardLeft.visible = false;
                this.showCardRight.visible = false;
                this.showCardBgLeft.visible = false;
                this.showCardBgRight.visible = false;
                this.isLeftPlay = false;
                this.isRightPlay = false;
            };
            // 在 	结算时	设置玩家allin的牌展示
            PlayerPanelUI.prototype.playerShowdown = function (cards) {
                if (cards === null || cards === undefined || cards.length === 0) {
                    this.imgBoardCard0.visible = false;
                    this.imgBoardCard1.visible = false;
                    return;
                }
                if (cards[0]) {
                    //设置showdown动画 数据
                    var cardImg = this.imgBoardCard0;
                    var imageName = HoldemPoker.Utility.getCardName(cards[0].cardNumber, cards[0].cardSuit);
                    cardImg.visible = true;
                    //cardImg.scale(0.7, 0.7);
                    cardImg.skin = imageName;
                }
                else {
                    //设置showdown动画 数据
                    var cardImg = this.imgBoardCard0;
                    cardImg.visible = true;
                    //cardImg.scale(0.7, 0.7);
                    cardImg.skin = HoldemPoker.Utility.getCardBackSkin();
                }
                if (cards[1]) {
                    var cardImg2 = this.imgBoardCard1;
                    var imageName2 = HoldemPoker.Utility.getCardName(cards[1].cardNumber, cards[1].cardSuit);
                    cardImg2.visible = true;
                    //cardImg2.scale(0.7, 0.7);
                    cardImg2.skin = imageName2;
                }
                else {
                    var cardImg2 = this.imgBoardCard1;
                    cardImg2.visible = true;
                    //cardImg2.scale(0.7, 0.7);
                    cardImg2.skin = HoldemPoker.Utility.getCardBackSkin();
                }
            };
            PlayerPanelUI.prototype.updateChipText = function (bankroll) {
                if (bankroll === null
                    || bankroll === undefined
                    || isNaN(bankroll)) {
                    this.chipsText.visible = false;
                    this.chipTextBg.visible = false;
                    this.currentBankroll = 0;
                    return;
                }
                this.currentBankroll = bankroll;
                this.chipsText.text = HoldemPoker.Utility.toNumberPattern(bankroll);
                if (!this.stateAllin.visible) {
                    this.chipsText.visible = true;
                    this.chipTextBg.visible = true;
                }
            };
            PlayerPanelUI.prototype.changeChipText = function (delta) {
                this.currentBankroll += delta;
                if (this.currentBankroll <= 0) {
                    this.currentBankroll = 0;
                }
                this.updateChipText(this.currentBankroll);
            };
            PlayerPanelUI.prototype.updateDealer = function (isD) {
                this.imgDeal.visible = isD;
            };
            //背景牌更新
            PlayerPanelUI.prototype.updateImgCards = function (seat) {
                this.imgCard0.visible = false;
                this.imgCard1.visible = false;
                if (seat) {
                    if (seat.actionState === 0 /* GAME_IN_STATE */ || seat.actionState === 2 /* ALLIN_STATE */) {
                        //注释原因因为  只有在发牌的时候才会把两张小手牌显示出来 弃牌 结算或者 其他不应该显示的设置为假
                        //固定显示的
                        this.imgCard0.skin = HoldemPoker.Utility.getCardBackSkin(HoldemPoker.CardSize.SM);
                        this.imgCard1.skin = HoldemPoker.Utility.getCardBackSkin(HoldemPoker.CardSize.SM);
                        this.imgCards.visible = true;
                        this.imgCard0.visible = true;
                        this.imgCard1.visible = true;
                    }
                    else {
                        this.imgCard0.visible = false;
                        this.imgCard1.visible = false;
                    }
                    //在showdownstate下  如果位置信息有 手牌信息 就要将小手牌隐藏
                    if (seat.holeCards !== null && seat.holeCards !== undefined && seat.holeCards.length > 0) {
                        this.imgCard0.visible = false;
                        this.imgCard1.visible = false;
                    }
                    //如果有排名自己的牌不显示
                    if (seat.rank > 0 && seat.state === HoldemPoker.msg.EPlayerState.sngover) {
                        this.imgCard0.visible = false;
                        this.imgCard1.visible = false;
                    }
                }
            };
            /**
             *
             * 恢复自己的面板 如果人站起 或者 玩家被打掉
             *
             * @abstract
             *
             * @memberOf PlayerPanelUI
             */
            PlayerPanelUI.prototype.recoverSelfPanel = function () {
                //还原 玩家头像位置
                this.playerPanel.pos(PlayerPanelUI.playerPosition[1][0], PlayerPanelUI.playerPosition[1][1]);
                this.quickChatBox.pos(PlayerPanelUI.playerPosition[1][0], PlayerPanelUI.playerPosition[1][1]);
                // this.onShowName(true);
                this.playerState.visible = false;
                this.updateSelfCardTypes();
                this.updateMascot(null);
            };
            PlayerPanelUI.prototype.updateByNlRoom = function (seat) {
                if (seat) {
                    this.visible = true;
                    this.showPlayerBaseInfo(seat);
                    this.updateChipText(seat.bankroll);
                    if (seat.state === HoldemPoker.msg.EPlayerState.sitdown
                        || seat.state === HoldemPoker.msg.EPlayerState.sngover) {
                        // || seat.state === msg.EPlayerState.rebuy) {
                        this.grayPanel(true);
                    }
                    else {
                        this.grayPanel(false);
                    }
                    //更新吉祥物
                    this.updateMascot(seat);
                }
                else {
                    this.updateBySeat(null);
                }
            };
            //每手更新 灰掉、隐藏、显示
            PlayerPanelUI.prototype.updateByNewRound = function (seat, isd) {
                // if (seat && seat.state !== msg.EPlayerState.rebuy) {
                this.imgDeal.visible = isd;
                if (seat) {
                    this.visible = true;
                    this.showPlayerBaseInfo(seat);
                    if (seat.state === HoldemPoker.msg.EPlayerState.sitdown || seat.state === HoldemPoker.msg.EPlayerState.sngover
                        || seat.actionState === 1 /* FOLD_STATE */) {
                        this.grayPanel(true);
                    }
                    else {
                        this.grayPanel(false);
                    }
                    //更新吉祥物
                    this.updateMascot(seat);
                    if (seat.aGroupOfTag && seat.aGroupOfTag === 1) {
                        this.player.groupTagBg.visible = true;
                        this.player.groupTag.visible = true;
                        this.player.suspicionTag.visible = false;
                    }
                    else {
                        if (seat.suspicionTag && seat.suspicionTag === 1) {
                            this.player.groupTagBg.visible = true;
                            this.player.suspicionTag.visible = true;
                            this.player.groupTag.visible = false;
                        }
                        else {
                            this.player.groupTagBg.visible = false;
                            this.player.groupTag.visible = false;
                            this.player.suspicionTag.visible = false;
                        }
                    }
                }
                else {
                    this.updateBySeat(null);
                }
            };
            PlayerPanelUI.prototype.showPlayerBaseInfo = function (seat) {
                this.playerPanel.alpha = 100;
                this.playerPanel.visible = true;
                this.seatBtn.visible = false;
                this.playerState.visible = true;
                var isSelf = HoldemPoker.Sys.players.self.isSelf(seat.playerId);
                this.updateComponentPosition(isSelf);
                this.updateManaged(seat);
                this.updateNameItem(seat.playerName);
                if (seat.state === HoldemPoker.msg.EPlayerState.sngover && seat.rank > 0) {
                    this.setSNGRankLabel(seat);
                }
                //更新吉祥物
                this.updateMascot(seat);
            };
            PlayerPanelUI.prototype.updateBySeat = function (seat, isDealer) {
                this.seatData = seat;
                // if (seat !== null && seat.state !== msg.EPlayerState.rebuy) {
                if (seat !== null) {
                    //console.log("updateSeat: " + JSON.stringify(seat));
                    this.playerPanel.alpha = 100;
                    this.playerPanel.visible = true;
                    this.seatBtn.visible = false;
                    this.playerState.visible = true;
                    var isSelf = HoldemPoker.Sys.players.self.isSelf(seat.playerId);
                    this.updateComponentPosition(isSelf);
                    // this.imgDeal.visible = seat.isDealer;
                    this.updateManaged(seat);
                    this.updateBet(seat, seat.bet);
                    this.updateNameItem(seat.playerName);
                    this.updateChipText(seat.bankroll);
                    this.updateUIWithAction(seat.actionResult, seat, false);
                    if (!isSelf) {
                        this.updateImgCards(seat);
                    }
                    else {
                        this.updateSelfCardTypes(seat.madeHands);
                    }
                    if (seat.aGroupOfTag && seat.aGroupOfTag === 1) {
                        this.player.groupTagBg.visible = true;
                        this.player.groupTag.visible = true;
                    }
                    else {
                        if (seat.suspicionTag && seat.suspicionTag === 1) {
                            this.player.groupTagBg.visible = true;
                            this.player.suspicionTag.visible = true;
                        }
                        else {
                            this.player.groupTagBg.visible = false;
                            this.player.groupTag.visible = false;
                            this.player.suspicionTag.visible = false;
                        }
                    }
                    if (seat.state === HoldemPoker.msg.EPlayerState.sngover && seat.rank > 0) {
                        this.setSNGRankLabel(seat);
                    }
                    //更新吉祥物
                    this.updateMascot(seat);
                    // this.sitIdtext.text = seat.sitId + "";
                }
                else {
                    this.playerPanel.visible = false;
                    this.seatBtn.visible = true;
                    this.player.avatarImg.texture = null;
                    // this.imgDeal.visible = false;
                    this.countDownBg.visible = false;
                    this.playerState.visible = false;
                    this.dragonPlayerStateAni.visible = false;
                    this.stateAllin.visible = false;
                    this.updateUIWithAction(0 /* NO_ACTION */, seat, false);
                    this.onShowName(false);
                    this.updateChipText(null);
                    this.updateManaged(null);
                    // this.updateBet(null, 0);
                    this.updateSelfCardTypes(null);
                    this.updateImgCards(null);
                    this.stopPokerClock();
                    this.showdown(false);
                    this.grayPanel(false);
                    this.quickChatBox.visible = false;
                    this.stopPlayVoice();
                }
                this.imgDeal.visible = isDealer;
                this.updategainsChipsNum(false);
            };
            PlayerPanelUI.prototype.cleanDelar = function () {
                this.imgDeal.visible = false;
            };
            PlayerPanelUI.prototype.updateComponentPosition = function (isSelf) {
                var posIdx = this.panelPosIdx[this.maxPanelCount - 2][this.clientpos];
                if (isSelf) {
                    posIdx = 6;
                }
                var compPos = this.componentPosition[posIdx];
                this.imgDeal.pos(compPos[0 /* dealer */][0], compPos[0 /* dealer */][1]);
                this.betImage.pos(compPos[1 /* chip */][0], compPos[1 /* chip */][1]);
                this.BetAniAnchor.pos(compPos[1 /* chip */][0], compPos[1 /* chip */][1]);
                this.imgCards.pos(compPos[3 /* holecard */][0], compPos[3 /* holecard */][1]);
                this.playerState.pos(compPos[4 /* actionstate */][0], compPos[4 /* actionstate */][1]);
                this.dragonPlayerStateAni.pos(this.playerState.x, this.playerState.y);
                this.betText.pos(compPos[2 /* chiptext */][0], compPos[2 /* chiptext */][1]);
                if (compPos[2 /* chiptext */][2] === 0) {
                    this.betText.align = "left";
                }
                else {
                    this.betText.align = "right";
                }
                this.AnteAniAnchor.pos(compPos[1 /* chip */][0], compPos[1 /* chip */][1]);
                this.mascotPanel.pos(compPos[5 /* mascotIndex */][0], compPos[5 /* mascotIndex */][1]);
            };
            PlayerPanelUI.prototype.updateNameItem = function (playerName) {
                this.nameItem.showChat(playerName, "#ffffff", 20, 86, false);
                //指定轴心点
                this.nameItem.pivot(this.nameItem.width / 2, this.nameItem.height / 2);
                this.nameItem.pos(this.playState.x, this.playState.y - 10);
                this.onShowName(true);
            };
            PlayerPanelUI.prototype.updategainsChipsNum = function (visible) {
                this.gainsChipsNum.visible = visible;
            };
            //显示自己的手牌牌型 只判断自己的手牌
            PlayerPanelUI.prototype.updateSelfCardTypes = function (type) {
                if (type && type !== HoldemPoker.msg.HandPowerTypes.NO_CARD) {
                    this.cardTypeBg.visible = true;
                    this.cardTypeText.visible = true;
                    this.cardTypeText.text = HoldemPoker.Utility.handPowerToString(type);
                    return;
                }
                this.cardTypeText.visible = false;
                this.cardTypeBg.visible = false;
            };
            PlayerPanelUI.prototype.updateBet = function (seat, currentBet, BB) {
                if (seat) {
                    var bet = currentBet;
                    if (bet === null || bet === undefined || bet === 0) {
                        this.currentBet = 0;
                        this.betText.text = "";
                        this.betImage.visible = false;
                    }
                    else {
                        this.currentBet = Math.round(bet);
                        this.betImage.skin = HoldemPoker.Utility.getBetImgColor(BB, bet);
                        this.betText.text = HoldemPoker.Utility.toNumberPattern(this.currentBet);
                        this.betImage.visible = true;
                    }
                }
                else {
                    this.currentBet = 0;
                    this.betText.text = "";
                    this.betImage.visible = false;
                }
            };
            PlayerPanelUI.prototype.asyncPlayerShowdown = function (cards, madeHands, isChipShow) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    return __generator(this, function (_a) {
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                _this.imgCards.visible = true; //小手牌 要显示出来 最后再消失
                                _this.showDown.visible = true;
                                //先不设置等到发完牌之后在设置
                                _this.winnerCardType.text = ""; //todo hzl
                                _this.winnerCardTypeBg.visible = false;
                                //根据小手牌的位置 判断应该播放哪个动画 在左边播放 left 在右边 播放右边
                                _this.playerShowdown(cards); //比牌动画 todo 。hzl
                                if (_this.imgCards.x > _this.width / 2) {
                                    _this.ani_showdown_right.play(0, false);
                                    _this.ani_showdown_right.on(Laya.Event.COMPLETE, _this, function () {
                                        _this.playerState.visible = isChipShow;
                                        resolve();
                                    });
                                    //摊牌动画开始的过程中，头像开始隐藏
                                    Laya.Tween.to(_this.playerPanel, { alpha: 0 }, 83, Laya.Ease.linearNone, Laya.Handler.create(_this, function () {
                                        _this.playerPanel.visible = false;
                                    }), 233);
                                }
                                else {
                                    _this.ani_showdown_left.play(0, false);
                                    _this.ani_showdown_left.on(Laya.Event.COMPLETE, _this, function () {
                                        _this.playerState.visible = isChipShow;
                                        resolve();
                                    });
                                    //摊牌动画开始的过程中，头像开始隐藏
                                    Laya.Tween.to(_this.playerPanel, { alpha: 0 }, 83, Laya.Ease.linearNone, Laya.Handler.create(_this, function () {
                                        _this.playerPanel.visible = false;
                                    }), 233);
                                }
                            })];
                    });
                });
            };
            /**
             * 播放亮牌动画
             * @param {msg.Card[]} cards
             * @returns {Promise<any>}
             * @memberof PlayerPanelUI
             */
            PlayerPanelUI.prototype.asyncPlayerShowCards = function (cards) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    return __generator(this, function (_a) {
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                if (cards === null || cards === undefined || cards.length === 0) {
                                    _this.showCardLeft.visible = false;
                                    _this.showCardRight.visible = false;
                                    _this.showCardBgLeft.visible = false;
                                    _this.showCardBgRight.visible = false;
                                    _this.showCardAniLeft.stop();
                                    _this.showCardAniRight.stop();
                                    resolve();
                                    return;
                                }
                                if (cards[0]) {
                                    //设置showdown动画 数据
                                    var imageName = HoldemPoker.Utility.getCardName(cards[0].cardNumber, cards[0].cardSuit);
                                    //cardImg.scale(0.7, 0.7);
                                    _this.showCardLeft.skin = imageName;
                                }
                                if (cards[1]) {
                                    var imageName2 = HoldemPoker.Utility.getCardName(cards[1].cardNumber, cards[1].cardSuit);
                                    //cardImg2.scale(0.7, 0.7);
                                    _this.showCardRight.skin = imageName2;
                                }
                                _this.playerPanel.visible = false;
                                _this.imgCards.visible = false;
                                _this.showCardBgLeft.visible = true;
                                _this.showCardBgRight.visible = true;
                                if (cards[0] && cards[1]) {
                                    if (!_this.isLeftPlay) {
                                        _this.isLeftPlay = true;
                                        _this.showCardAniLeft.play(0, false);
                                        _this.showCardAniLeft.interval = _this.aniRaio;
                                    }
                                    if (!_this.isRightPlay) {
                                        _this.isRightPlay = true;
                                        _this.showCardAniRight.play(0, false);
                                        _this.showCardAniRight.interval = _this.aniRaio;
                                    }
                                    _this.showCardAniLeft.on(Laya.Event.COMPLETE, _this, function () {
                                        resolve();
                                    });
                                }
                                else if (cards[0] && !cards[1]) {
                                    if (!_this.isLeftPlay) {
                                        _this.isLeftPlay = true;
                                        _this.showCardAniLeft.play(0, false);
                                        _this.showCardAniLeft.interval = _this.aniRaio;
                                    }
                                    _this.showCardAniLeft.on(Laya.Event.COMPLETE, _this, function () {
                                        resolve();
                                    });
                                }
                                else if (!cards[0] && cards[1]) {
                                    if (!_this.isRightPlay) {
                                        _this.isRightPlay = true;
                                        _this.showCardAniRight.play(0, false);
                                        _this.showCardAniRight.interval = _this.aniRaio;
                                    }
                                    _this.showCardAniRight.on(Laya.Event.COMPLETE, _this, function () {
                                        resolve();
                                    });
                                }
                            })];
                    });
                });
            };
            PlayerPanelUI.prototype.asyncPlayerWin = function (madeHands) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    return __generator(this, function (_a) {
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                _this.ani_win.play(0, false);
                                _this.ani_win.on(Laya.Event.COMPLETE, _this, function () {
                                    // this.winner.visible = true;
                                    resolve();
                                });
                            })];
                    });
                });
            };
            PlayerPanelUI.prototype.clearStatus = function (cleanPlayState) {
                if (cleanPlayState) {
                    this.playState.visible = false;
                    this.stateAllin.visible = false;
                }
                //this.playerStateBg.visible = false;
                this.actionStateBg.visible = false;
                this.actionState.visible = false;
                this.chipTextBg.visible = true;
                this.nameBg.visible = true;
                this.nameItem.visible = true;
                this.dragonPlayerStateAni.visible = false;
            };
            //通过加注量 获取 玩家的
            // 以大盲注BB为基数，3BB以下使用绿色，3BB- 10BB黑色，10BB- 30BB用紫色，30BB以上使用红
            /*
             private playCallActionAni(): Promise<any> {
             return new Promise((resolve, reject) => {
             this.playerActionAni.visible = true;
             this.playerActionAni.play(0, false, "call");
             this.playerActionAni.once(Laya.Event.COMPLETE, this, () => {
             this.playerActionAni.visible = false;
             resolve();
             });
    
             caller.playerState.addChild(caller.playerCallAcitonAni);
             caller.playerState.addChild(caller.playerCallAcitonStateAni);
             caller.playerPanel.addChildAt(caller.playerCallLoopAni, 0);
    
             caller.playerCallAcitonAni.pos(caller.playState.x, caller.playState.y);
             caller.playerCallLoopAni.pos(caller.actionSateBg.x, caller.actionSateBg.y);
             //caller.playerCallAcitonStateAni.pos(caller.playerStateBg.x, caller.playerStateBg.y);
    
             caller.playerCallAcitonAni.visible = true;
             caller.playerCallLoopAni.visible = true;
             caller.playerCallAcitonStateAni.visible = true;
    
             caller.playerCallAcitonStateAni.play(0, false);//第一段动画
             caller.playerCallAcitonStateAni.once(Laya.Event.COMPLETE, caller, () => {
             caller.playerCallAcitonStateAni.visible = false;
             // 状态动画
             caller.playerState.removeChild(caller.playerCallAcitonStateAni);
             //圆环动画
             caller.playerCallLoopAni.play(0, false);
             caller.playerCallLoopAni.once(Laya.Event.COMPLETE, caller, () => {
             caller.actionSateBg.visible = true;
             caller.playerCallLoopAni.visible = false;
             caller.playerPanel.removeChild(caller.playerCallLoopAni);
             });
             caller.playerCallAcitonAni.play(0, false);//第二段动画
             caller.playerCallAcitonAni.once(Laya.Event.COMPLETE, caller, () => {
             caller.playState.visible = true;
             caller.playerCallAcitonAni.visible = false;
             caller.playerState.removeChild(caller.playerCallAcitonAni);
             resolve();
             });
    
             });
             });
             }
             */
            PlayerPanelUI.prototype.playPlayerActionAni = function (name) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    if (name === "allin") {
                        _this.playerState.visible = true;
                        _this.stateAllin.scale(0, 0);
                        _this.showAllinState(true);
                        Laya.Tween.to(_this.stateAllin, {
                            scaleX: 1,
                            scaleY: 1
                        }, 625, _this.esseOut, Laya.Handler.create(_this, function () {
                            resolve();
                        }));
                    }
                    else {
                        if (HoldemPoker.Sys.isSimple) {
                            _this.playState.skin = HoldemPoker.Sys.localization.getResDir("1334/actionstate/simple/", name + "_state.png");
                            if (name === "fold") {
                                resolve();
                            }
                            else {
                                _this.actionStateAnim.play(0, false);
                                _this.playState.visible = true;
                                _this.actionStateAnim.once(Laya.Event.COMPLETE, _this, function () {
                                    resolve();
                                });
                            }
                        }
                        else {
                            _this.playState.skin = HoldemPoker.Sys.localization.getResDir("1334/actionstate/", name + "_state.png");
                            _this.dragonPlayerStateAni.setSlotSkin("play_action_up", HoldemPoker.Sys.loader.getRes(HoldemPoker.Sys.localization.getResDir("1334/actionstate/", name + "_state.png")));
                            if (name === "check") {
                                //check 和 call用的相同bg资源
                                name = "call";
                            }
                            _this.dragonPlayerStateAni.setSlotSkin("play_action_down", HoldemPoker.Sys.loader.getRes("1334/actionstate/" + name + "_state_bg.png"));
                            if (name === "fold") {
                                resolve();
                            }
                            else {
                                if (_this.stateAnimPlay()) {
                                    _this.dragonPlayerStateAni.mArmature.once(Laya.Event.STOPPED, _this, function () {
                                        resolve();
                                    });
                                }
                                else {
                                    resolve();
                                }
                            }
                        }
                    }
                });
            };
            PlayerPanelUI.prototype.setPlayerAction = function (action) {
                this.dragonPlayerStateAni.visible = false;
                if (HoldemPoker.Sys.isSimple) {
                    this.playState.skin = HoldemPoker.Sys.localization.getResDir("1334/actionstate/simple/", action + "_state.png");
                }
                else {
                    this.playState.skin = HoldemPoker.Sys.localization.getResDir("1334/actionstate/", action + "_state.png");
                }
                this.playState.visible = true;
                this.chipTextBg.visible = true;
                this.nameBg.visible = true;
                this.stateAllin.visible = false;
                if (action === "check") {
                    //check 和 call用的相同bg和loop资源
                    action = "call";
                }
                else if (action === "allin") {
                    this.showAllinState(true);
                }
            };
            PlayerPanelUI.prototype.showAllinState = function (showAllin) {
                this.playState.visible = !showAllin;
                this.chipTextBg.visible = !showAllin;
                this.nameBg.visible = !showAllin;
                this.stateAllin.visible = showAllin;
            };
            PlayerPanelUI.prototype.playAvatarCircleAnim = function (action) {
                if (action === "check") {
                    //check 和 call用的相同bg和loop资源
                    action = "call";
                }
                if (action !== "fold") {
                    this.actionStateBg.scale(0.8, 0.8);
                    this.actionStateBg.visible = true;
                    this.actionStateBg.texture = HoldemPoker.Sys.loader.getRes("1334/actionstate/" + action + "_loop_bg.png");
                    Laya.Tween.to(this.actionStateBg, { scaleX: 1, scaleY: 1 }, 300, this.esseOut);
                    if (action === "allin") {
                        this.actionState.texture = HoldemPoker.Sys.loader.getRes("1334/actionstate/" + action + "_loop.png");
                    }
                    else {
                        this.actionState.texture = HoldemPoker.Sys.loader.getRes("1334/actionstate/call_loop.png");
                    }
                    //this.actionState.texture = Sys.loader.getRes(`1334/actionstate/${action}_loop.png`);
                    this.actionState.visible = true;
                }
                else {
                    this.actionState.visible = false;
                    this.actionStateBg.visible = false;
                    this.imgCards.visible = false;
                }
            };
            PlayerPanelUI.prototype.esseOut = function (t, b, c, d, s) {
                if (s === undefined) {
                    s = 2.5;
                }
                return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
            };
            PlayerPanelUI.prototype.updatePlayerAction = function (action, playAnimation) {
                var _this = this;
                this.clearStatus(false);
                this.onShowName(false);
                if (action === "fold") {
                    this.grayPanel(true);
                }
                else if (action === "allin") {
                    this.showAllinState(true);
                }
                if (playAnimation) {
                    //播放动画
                    this.dragonPlayerStateAni.setSlotSkin("play_action_up", HoldemPoker.Sys.loader.getRes(HoldemPoker.Sys.localization.getResDir("1334/actionstate/", action + "_state.png")));
                    this.playPlayerActionAni(action).then(function () {
                        _this.setPlayerAction(action);
                    });
                    if (HoldemPoker.Sys.isSimple) {
                    }
                    else {
                        this.playAvatarCircleAnim(action);
                    }
                }
                else {
                    this.setPlayerAction(action);
                }
            };
            //玩家操作只走这个流程 action 或者 flopround gains 都用这个
            PlayerPanelUI.prototype.updateUIWithAction = function (action, seat, playAnimation) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        if (seat && (seat.state === HoldemPoker.msg.EPlayerState.sngover && seat.rank > 0)) {
                            this.clearStatus(false);
                            this.onShowName(true);
                            return [2 /*return*/];
                        }
                        if (seat.state === HoldemPoker.msg.EPlayerState.sitdown || seat.state === HoldemPoker.msg.EPlayerState.fold) {
                            this.grayPanel(true);
                        }
                        else {
                            this.grayPanel(false);
                        }
                        this.onShowName(false);
                        if (action === 0 /* NO_ACTION */) {
                            this.clearStatus(false);
                            this.onShowName(true);
                        }
                        else if (action === 2 /* FOLD_ACTION */) {
                            this.updatePlayerAction("fold", playAnimation);
                        }
                        else if (action === 16 /* ALLIN_ACTION */) {
                            this.updatePlayerAction("allin", playAnimation);
                        }
                        else if (action === 1 /* CALL_ACTION */) {
                            this.updatePlayerAction("call", playAnimation);
                        }
                        else if (action === 4 /* CHECK_ACTION */) {
                            this.updatePlayerAction("check", playAnimation);
                        }
                        else if (action === 8 /* RAISE_ACTION */) {
                            this.updatePlayerAction("raise", playAnimation);
                        }
                        return [2 /*return*/];
                    });
                });
            };
            PlayerPanelUI.prototype.grayPanel = function (gray) {
                // this.wholePanel.filters = gray ? [Utility.grayFilter()] : null;
                HoldemPoker.Utility.setGray(this.wholePanel, gray);
                this.rankBox.filters = [];
                this.rankLabel.filters = [];
            };
            PlayerPanelUI.prototype.onShowName = function (visible) {
                this.nameItem.visible = visible;
                this.nameBg.visible = visible;
                if (visible) {
                    this.playState.visible = false;
                }
            };
            /**
             * 玩家坐下
             *
             * @private
             *
             * @memberOf InGameUI
             */
            PlayerPanelUI.prototype.onSitSeat = function () {
                this.event(HoldemPoker.GEvent.INGAME_SIT, this.serverPos);
            };
            //播放语音动画
            PlayerPanelUI.prototype.startPlayVoice = function () {
                if (this.voiceAnimation === null) {
                    this.voiceAnimation = new laya.display.Animation();
                    //通过图片名设置数据
                    this.voiceAnimation.source = "1334/ingame/voice0.png,1334/ingame/voice1.png,1334/ingame/voice3.png";
                    this.voiceAnimation.interval = 500;
                    this.voiceImg.addChild(this.voiceAnimation);
                }
                this.voiceImg.visible = true;
                this.voiceAnimation.play(1, true);
            };
            //停止播放语音动画
            PlayerPanelUI.prototype.stopPlayVoice = function () {
                if (this.voiceAnimation) {
                    this.voiceImg.visible = false;
                    this.voiceAnimation.stop();
                }
            };
            /**
             * 隐藏倒计时
             * 当玩家操作完成后取消倒计时
             * @private
             *
             * @memberOf PlayerPanelUI
             */
            PlayerPanelUI.prototype.stopPokerClock = function () {
                this.countDownMask.graphics.clear();
                this.countDown.visible = false;
                this.countDownBg.visible = false;
                this.playerPoint.visible = false;
                this.playerPoint.pos(68, 13);
                Laya.timer.clear(this, this.updateProgress);
                this.actionTimeTxt.visible = false;
            };
            //暂停 录像用
            PlayerPanelUI.prototype.pauseCountDown = function () {
                Laya.timer.clear(this, this.updateProgress);
            };
            PlayerPanelUI.prototype.resumeCountDown = function () {
                this.lastUpdateTime = Laya.timer.currTimer;
                Laya.timer.loop(33, this, this.updateProgress);
            };
            PlayerPanelUI.prototype.onVideoFF = function (times) {
                Laya.timer.clear(this, this.updateProgress);
                this.loopSpeed = times;
            };
            //清除倒计时的灰化，弃牌除外
            PlayerPanelUI.prototype.clearGray = function () {
                HoldemPoker.Utility.setGray(this.player, false);
            };
            //桌面上的其他玩家是有这个倒计时时间的停止计时器
            PlayerPanelUI.prototype.startPokerClock = function (thinkTime, actionTime) {
                var da = new Date();
                var myTime = da.getTime();
                var actTime = Number(actionTime);
                if (actionTime > 100000) {
                    myTime = myTime + HoldemPoker.Sys.mistiming;
                    actionTime = actTime - myTime;
                    console.log(actTime + "-" + myTime + "=" + actionTime + ":" + HoldemPoker.Sys.mistiming);
                    this.actionTime = actionTime;
                }
                else {
                    this.actionTime = actionTime * 1000;
                }
                // this.thinkTime = thinkTime * 1000;
                var numTime = Number(thinkTime);
                if (numTime > 1000) {
                    myTime = myTime + HoldemPoker.Sys.mistiming;
                    thinkTime = numTime - myTime;
                    console.log(numTime + "-" + myTime + "=" + thinkTime + ":" + HoldemPoker.Sys.mistiming);
                    this.thinkTime = thinkTime;
                }
                else {
                    this.thinkTime = thinkTime * 1000;
                }
                this.stopPokerClock();
                if (this.thinkTime > this.actionTime) {
                    this.thinkTime = this.actionTime;
                }
                this.countDownMask.graphics.clear();
                this.countDown.visible = true;
                this.countDownBg.visible = true;
                this.playerPoint.visible = true;
                this.playerPoint.scale(1, 1);
                this.flashPointAni.stop();
                Laya.timer.clear(this, this.updateProgress);
                Laya.timer.loop(33, this, this.updateProgress);
                this.lastUpdateTime = Laya.timer.currTimer;
                if (HoldemPoker.Sys.isSimple) {
                    this.actionTimeTxt.filters = [HoldemPoker.Utility.getGreenFilter()];
                }
                else {
                    this.actionTimeTxt.filters = [HoldemPoker.Utility.getRedFilter()];
                }
                this.actionTimeTxt.visible = true;
                HoldemPoker.Utility.setGray(this.player, true);
            };
            PlayerPanelUI.prototype.updateProgress = function () {
                var countDownTxt = Math.floor(this.thinkTime / 1000);
                var str0 = "";
                if (countDownTxt < 10 && countDownTxt >= 0) {
                    str0 = "0";
                }
                if (countDownTxt < 0) {
                    str0 = "0";
                }
                this.actionTimeTxt.text = str0 + countDownTxt;
                var agl = 360.0 / this.actionTime;
                //一次转多少度 。
                var delta = Laya.timer.currTimer - this.lastUpdateTime;
                this.thinkTime -= delta * this.loopSpeed;
                if (this.thinkTime < 30) {
                    this.thinkTime = 1;
                    Laya.timer.clear(this, this.updateProgress);
                    this.flashPointAni.play(0, true);
                    return;
                }
                this.countDownMask.graphics.clear();
                if (this.thinkTime <= 0) {
                    this.stopPokerClock();
                }
                else {
                    var w = this.countDown.width;
                    var h = this.countDown.height;
                    var r = w / 2.0 - 1;
                    this.countDownMask.graphics.drawPie(w / 2, h / 2, w / 2, -90, (agl * (this.actionTime - this.thinkTime)) - 90, "#ff0000");
                    var aagel = agl * (this.actionTime - this.thinkTime);
                    var hudu = (2.0 * Math.PI / 360.0) * (aagel);
                    var x = (r - 2) * Math.sin(hudu) + this.countDownBg.x;
                    var y = this.countDownBg.y - (r - 2) * Math.cos(hudu);
                    this.playerPoint.pos(x, y);
                }
                this.lastUpdateTime = Laya.timer.currTimer;
            };
            PlayerPanelUI.prototype.onShowPlayerInfo = function () {
                this.event(HoldemPoker.GEvent.INGAME_SHOW_PLAYER, this.serverPos);
            };
            /**
             * 更新吉祥物信息
             * @param seat
             */
            PlayerPanelUI.prototype.updateMascot = function (seat) {
                if (seat && seat.mascotItem) {
                    console.log(seat.mascotItem.name);
                    this.mascotPanel.visible = true;
                    this.mascotPanel.skin = seat.mascotItem.smallIcon;
                }
                else {
                    this.mascotPanel.visible = false;
                }
            };
            /**
             * 监听更换牌皮肤
             */
            PlayerPanelUI.prototype.updateCardSkin = function () {
                //小牌
                this.imgCard0.skin = HoldemPoker.Utility.getCardBackSkin(HoldemPoker.CardSize.SM);
                this.imgCard1.skin = HoldemPoker.Utility.getCardBackSkin(HoldemPoker.CardSize.SM);
                this.showCardBgLeft.skin = HoldemPoker.Utility.getCardBackSkin();
                this.showCardBgRight.skin = HoldemPoker.Utility.getCardBackSkin();
            };
            /**
             * 显示聊天信息
             * @param {wesai.HoldemPoker.msg.ShowEmojiResponse} data
             * @param {boolean} selfPosLeft
             */
            PlayerPanelUI.prototype.showQuickChat = function (data, selfPosLeft) {
                var _this = this;
                if (data) {
                    var chatObj = JSON.parse(data.emojiId);
                    this.quickChatBox.visible = true;
                    this.quickChatImg.visible = false;
                    this.quickChatWord.visible = false;
                    Laya.timer.clear(this, this.onHideChatMessage);
                    var chatStr = HoldemPoker.QuickChatHelper.getChatEntity(chatObj.type, chatObj.index);
                    if (chatObj.type === HoldemPoker.QuickChatType.Word) {
                        this.quickChatWord.label = chatStr;
                        //计算的宽度有问题
                        // let textWidth = this.quickChatWord.text.textWidth + 20;
                        var textWidth = 0;
                        for (var i = 0; i < chatStr.length; i++) {
                            textWidth += 20;
                        }
                        textWidth += 20;
                        this.quickChatWord.width = textWidth;
                        this.quickChatWord.x = this.computeChatPosition(textWidth, selfPosLeft);
                        this.fadeIn(this.quickChatWord).then(function () {
                            Laya.timer.once(2500, _this, _this.onHideChatMessage, [_this.quickChatWord], true);
                        });
                    }
                    else if (chatObj.type === HoldemPoker.QuickChatType.Emoji) {
                        this.quickChatImg.skin = chatStr;
                        this.fadeIn(this.quickChatImg).then(function () {
                            Laya.timer.once(2500, _this, _this.onHideChatMessage, [_this.quickChatImg], true);
                        });
                    }
                }
            };
            /**
             * 文字位置
             * @param {number} textWidth
             * @param {boolean} selfPosLeft
             * @returns {number}
             */
            PlayerPanelUI.prototype.computeChatPosition = function (textWidth, selfPosLeft) {
                // if (Sys.isPad) {
                //     return (this.quickChatBox.width - textWidth) / 2;
                // }
                var x = 20;
                var posIndex = this.panelPosIdx[this.maxPanelCount - 2][this.clientpos];
                if (selfPosLeft) {
                    posIndex = 6;
                }
                switch (posIndex) {
                    //中间
                    case 0:
                    case 2:
                    case 3:
                    case 4:
                        x = (this.quickChatBox.width - textWidth) / 2;
                        break;
                    //左边
                    case 1:
                    case 6:
                        break;
                    //右边
                    case 5:
                        x = -textWidth + this.quickChatBox.width - 20;
                        break;
                }
                return x;
            };
            /**
             * 隐藏聊天信息
             * @param target
             */
            PlayerPanelUI.prototype.onHideChatMessage = function (target) {
                var _this = this;
                if (this && target) {
                    this.fadeOut(target).then(function () {
                        _this.quickChatBox.visible = false;
                    });
                }
            };
            /**
             * 渐显
             * @param target
             * @param {number} duration
             * @returns {Promise<Promise<any> | Promise>}
             */
            PlayerPanelUI.prototype.fadeIn = function (target, duration) {
                if (duration === void 0) { duration = 200; }
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    return __generator(this, function (_a) {
                        target.visible = true;
                        target.alpha = 0;
                        Laya.Tween.clearTween(target);
                        return [2 /*return*/, new Promise(function (resolve) {
                                Laya.Tween.to(target, {
                                    alpha: 1
                                }, duration, null, new Laya.Handler(_this, resolve));
                            })];
                    });
                });
            };
            /**
             * 渐隐
             * @param target
             * @param {number} duration
             * @returns {Promise<any> | Promise}
             */
            PlayerPanelUI.prototype.fadeOut = function (target, duration) {
                var _this = this;
                if (duration === void 0) { duration = 200; }
                target.visible = true;
                target.alpha = 1;
                Laya.Tween.clearTween(target);
                return new Promise(function (resolve) {
                    Laya.Tween.to(target, {
                        alpha: 0
                    }, duration, null, new Laya.Handler(_this, function () {
                        target.visible = false;
                        resolve();
                    }));
                });
            };
            //头像移动 的位置
            PlayerPanelUI.playerPosition = HoldemPoker.Sys.isPad ? [[-396, 34], [7, 0]] : [[-296, 34], [7, 0]];
            return PlayerPanelUI;
        }(ui.playerPanelUI));
        HoldemPoker.PlayerPanelUI = PlayerPanelUI;
    })(HoldemPoker = wesai.HoldemPoker || (wesai.HoldemPoker = {}));
})(wesai || (wesai = {}));
//# sourceMappingURL=PlayerPanelUI.js.map