var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 * 加注
 */
var wesai;
(function (wesai) {
    var HoldemPoker;
    (function (HoldemPoker) {
        var VFlop = /** @class */ (function () {
            function VFlop(vc) {
                this.vc = vc;
                this.videoUI = vc.videoUI;
            }
            VFlop.prototype.showPubCard = function (cards) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(this.vc.pubCard && this.vc.pubCard.length === 0)) return [3 /*break*/, 7];
                                this.asyncDoSidePotsAni();
                                return [4 /*yield*/, this.updateFlopCard(cards)];
                            case 1:
                                _a.sent();
                                if (!(cards.length > 3)) return [3 /*break*/, 4];
                                return [4 /*yield*/, HoldemPoker.Utility.waitForSeconds(500)];
                            case 2:
                                _a.sent();
                                return [4 /*yield*/, this.updateTurnCard(cards[3])];
                            case 3:
                                _a.sent();
                                _a.label = 4;
                            case 4:
                                if (!(cards.length > 4)) return [3 /*break*/, 7];
                                return [4 /*yield*/, HoldemPoker.Utility.waitForSeconds(1000)];
                            case 5:
                                _a.sent();
                                return [4 /*yield*/, this.updateRiverCard(cards[4])];
                            case 6:
                                _a.sent();
                                _a.label = 7;
                            case 7:
                                if (!(this.vc.pubCard.length === 3)) return [3 /*break*/, 12];
                                this.asyncDoSidePotsAni();
                                if (!(cards.length > 3)) return [3 /*break*/, 9];
                                return [4 /*yield*/, this.updateTurnCard(cards[3])];
                            case 8:
                                _a.sent();
                                _a.label = 9;
                            case 9:
                                if (!(cards.length > 4)) return [3 /*break*/, 12];
                                return [4 /*yield*/, HoldemPoker.Utility.waitForSeconds(500)];
                            case 10:
                                _a.sent();
                                return [4 /*yield*/, this.updateRiverCard(cards[4])];
                            case 11:
                                _a.sent();
                                _a.label = 12;
                            case 12:
                                if (!(this.vc.pubCard.length === 4)) return [3 /*break*/, 14];
                                this.asyncDoSidePotsAni();
                                if (!(cards.length === 5)) return [3 /*break*/, 14];
                                return [4 /*yield*/, this.updateRiverCard(cards[4])];
                            case 13:
                                _a.sent();
                                _a.label = 14;
                            case 14: return [2 /*return*/];
                        }
                    });
                });
            };
            VFlop.prototype.asyncDoSidePotsAni = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(this.vc.pots && this.vc.pots.length > 1
                                    && this.vc.pots.length > this.vc.videoUI.sidePotGrp.numChildren)) return [3 /*break*/, 2];
                                return [4 /*yield*/, HoldemPoker.UIAnimator.asyncPotToSidePotAinByVideo(this.vc)];
                            case 1:
                                _a.sent();
                                _a.label = 2;
                            case 2: return [2 /*return*/];
                        }
                    });
                });
            };
            VFlop.prototype.updateFlopCard = function (cards) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var i, imageName;
                    return __generator(this, function (_a) {
                        for (i = 0; i < 3; i++) {
                            imageName = HoldemPoker.Utility.getCardName(cards[i].cardNumber, cards[i].cardSuit);
                            this.videoUI.dragonFlop.setSlotSkin("card_turn_" + (i + 1), HoldemPoker.Sys.loader.getRes(imageName));
                            this.videoUI.dragonFlop.setSlotSkin("card_" + (i + 1), HoldemPoker.Sys.loader.getRes(imageName));
                        }
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                if (_this.videoUI.flopPlay()) {
                                    _this.videoUI.dragonFlop.mArmature.once(Laya.Event.STOPPED, _this, function () {
                                        _this.videoUI.dragonFlop.visible = false;
                                        for (var i = 0; i < 3; i++) {
                                            _this.showBoardCard(i, cards[i]);
                                        }
                                        _this.setCardHighlight();
                                        _this.vc.videoUI.foldHoleCards();
                                        resolve();
                                    });
                                }
                                else {
                                    for (var i = 0; i < 3; i++) {
                                        _this.showBoardCard(i, cards[i]);
                                    }
                                    _this.setCardHighlight();
                                    _this.vc.videoUI.foldHoleCards();
                                    resolve();
                                }
                            })];
                    });
                });
            };
            VFlop.prototype.updateTurnCard = function (card) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var imageName;
                    return __generator(this, function (_a) {
                        imageName = HoldemPoker.Utility.getCardName(card.cardNumber, card.cardSuit);
                        this.videoUI.dragonTurn.setSlotSkin("card_4", HoldemPoker.Sys.loader.getRes(imageName));
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                if (_this.videoUI.turnPlay()) {
                                    // this.getNoInsuranceTip(1);
                                    _this.videoUI.dragonTurn.mArmature.once(Laya.Event.STOPPED, _this, function () {
                                        _this.videoUI.dragonTurn.visible = false;
                                        _this.showBoardCard(3, card);
                                        _this.setCardHighlight();
                                        _this.vc.videoUI.foldHoleCards();
                                        resolve();
                                    });
                                }
                                else {
                                    _this.showBoardCard(3, card);
                                    _this.setCardHighlight();
                                    _this.vc.videoUI.foldHoleCards();
                                    resolve();
                                }
                            })];
                    });
                });
            };
            VFlop.prototype.updateRiverCard = function (card) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var imageName;
                    return __generator(this, function (_a) {
                        imageName = HoldemPoker.Utility.getCardName(card.cardNumber, card.cardSuit);
                        this.videoUI.dragonRiver.setSlotSkin("card_5", HoldemPoker.Sys.loader.getRes(imageName));
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                if (_this.videoUI.riverPlay()) {
                                    // this.getNoInsuranceTip(2);
                                    _this.videoUI.dragonRiver.mArmature.once(Laya.Event.STOPPED, _this, function () {
                                        _this.videoUI.dragonRiver.visible = false;
                                        _this.showBoardCard(4, card);
                                        _this.setCardHighlight();
                                        _this.vc.videoUI.foldHoleCards();
                                        resolve();
                                    });
                                }
                                else {
                                    _this.showBoardCard(4, card);
                                    _this.setCardHighlight();
                                    _this.vc.videoUI.foldHoleCards();
                                    resolve();
                                }
                            })];
                    });
                });
            };
            VFlop.prototype.showBoardCard = function (index, card) {
                if (index >= 0 && index < this.videoUI.boardCardGrp.numChildren) {
                    var cardImg = this.videoUI.boardCardGrp.getChildAt(index);
                    if (card) {
                        this.videoUI.boardCardGrp.visible = true;
                        var imageName = HoldemPoker.Utility.getCardName(card.cardNumber, card.cardSuit);
                        cardImg.visible = true;
                        cardImg.x = VFlop.boardcardsPosition[index][0];
                        cardImg.y = VFlop.boardcardsPosition[index][1];
                        cardImg.scaleX = 1;
                        cardImg.scaleY = 1;
                        cardImg.texture = HoldemPoker.Sys.loader.getRes(imageName);
                        //cardImg.texture = Sys.loader.getRes(imageName);
                    }
                    else {
                        cardImg.visible = false;
                        cardImg.filters = null;
                        var big = cardImg.getChildAt(0);
                        big.skin = "1334/poker/card_shadow.png";
                    }
                }
            };
            //高亮牌型
            VFlop.prototype.setCardHighlight = function () {
                var selfSeatData = this.vc.videoUI.getSelfSeat();
                if (!selfSeatData) {
                    return;
                }
                var type = selfSeatData.madeHands;
                var cards = new Array;
                for (var _i = 0, _a = selfSeatData.holeCards; _i < _a.length; _i++) {
                    var mc = _a[_i];
                    cards.push(mc);
                }
                for (var _b = 0, _c = this.vc.pubCard; _b < _c.length; _b++) {
                    var mc = _c[_b];
                    cards.push(mc);
                }
                cards = cards.sort(this.cardSort);
                for (var i = 0; i < cards.length; i++) {
                    cards[i].tag = 1;
                }
                switch (type) {
                    case HoldemPoker.msg.HandPowerTypes.HIGH_CARD:
                        for (var i = 0; i < cards.length; i++) {
                            if (i < 5) {
                                cards[i].tag = 1;
                            }
                            else {
                                cards[i].tag = 0;
                            }
                        }
                        break;
                    case HoldemPoker.msg.HandPowerTypes.ONE_PAIR:
                        for (var i = 0; i < cards.length; i++) {
                            var one_1 = new Array;
                            one_1.push(cards[i]);
                            for (var j = i + 1; j < cards.length; j++) {
                                if (cards[i].cardNumber === cards[j].cardNumber) {
                                    one_1.push(cards[j]);
                                    break;
                                }
                            }
                            if (one_1.length === 2) {
                                for (var _d = 0, one_2 = one_1; _d < one_2.length; _d++) {
                                    var sc = one_2[_d];
                                    sc.tag = 2;
                                }
                            }
                        }
                        var h = 0;
                        for (var i = 0; i < cards.length; i++) {
                            if (cards[i].tag !== 2) {
                                if (h < 3) {
                                    cards[i].tag = 1;
                                    h++;
                                }
                                else {
                                    cards[i].tag = 0;
                                }
                            }
                        }
                        break;
                    case HoldemPoker.msg.HandPowerTypes.TWO_PAIR:
                        var one = new Array;
                        for (var i = 0; i < cards.length; i++) {
                            // one.push(cards[i]);
                            for (var j = i + 1; j < cards.length; j++) {
                                if (cards[i].cardNumber === cards[j].cardNumber) {
                                    one.push(cards[i]);
                                    one.push(cards[j]);
                                    break;
                                }
                            }
                            if (one.length === 4) {
                                for (var _e = 0, one_3 = one; _e < one_3.length; _e++) {
                                    var sc = one_3[_e];
                                    sc.tag = 2;
                                }
                                break;
                            }
                        }
                        h = 0;
                        for (var i = 0; i < cards.length; i++) {
                            if (cards[i].tag !== 2) {
                                if (h < 1) {
                                    cards[i].tag = 1;
                                    h++;
                                }
                                else {
                                    cards[i].tag = 0;
                                }
                            }
                        }
                        break;
                    case HoldemPoker.msg.HandPowerTypes.THREE_OF_A_KIND:
                        var three = 0;
                        for (var i = 0; i < cards.length; i++) {
                            three = 0;
                            var threeCard = new Array;
                            threeCard.push(cards[i]);
                            for (var j = i + 1; j < cards.length; j++) {
                                if (cards[i].cardNumber === cards[j].cardNumber) {
                                    threeCard.push(cards[j]);
                                    three++;
                                    if (three === 2) {
                                        break;
                                    }
                                }
                            }
                            if (threeCard.length === 3) {
                                for (var _f = 0, threeCard_1 = threeCard; _f < threeCard_1.length; _f++) {
                                    var sc = threeCard_1[_f];
                                    sc.tag = 2;
                                }
                                break;
                            }
                        }
                        h = 0;
                        for (var i = 0; i < cards.length; i++) {
                            if (cards[i].tag !== 2) {
                                if (h < 2) {
                                    cards[i].tag = 1;
                                    h++;
                                }
                                else {
                                    cards[i].tag = 0;
                                }
                            }
                        }
                        break;
                    case HoldemPoker.msg.HandPowerTypes.FLUSH://同花 proto里写错了
                        var straight = 0;
                        for (var i = 0; i < cards.length; i++) {
                            straight = 0;
                            var straightCard = new Array;
                            straightCard.push(cards[i]);
                            for (var j = i + 1; j < cards.length; j++) {
                                if (cards[i].cardSuit === cards[j].cardSuit) {
                                    straightCard.push(cards[j]);
                                    straight++;
                                    if (straight === 4) {
                                        break;
                                    }
                                }
                            }
                            if (straightCard.length === 5) {
                                for (var _g = 0, straightCard_1 = straightCard; _g < straightCard_1.length; _g++) {
                                    var sc = straightCard_1[_g];
                                    sc.tag = 2;
                                }
                                break;
                            }
                        }
                        for (var i = 0; i < cards.length; i++) {
                            if (cards[i].tag !== 2) {
                                cards[i].tag = 0;
                            }
                        }
                        break;
                    case HoldemPoker.msg.HandPowerTypes.STRAIGHT://顺子 proto里写错了
                        var flush = 0;
                        var start = 0;
                        for (var i = 0; i < cards.length; i++) {
                            flush = 0;
                            var flushCard = new Array;
                            flushCard.push(cards[i]);
                            start = cards[i].cardNumber;
                            for (var j = i + 1; j < cards.length; j++) {
                                if (start - 1 === cards[j].cardNumber) {
                                    start = cards[j].cardNumber;
                                    flushCard.push(cards[j]);
                                    flush++;
                                    if (flush === 4) {
                                        break;
                                    }
                                }
                            }
                            if (flushCard.length === 5) {
                                for (var _h = 0, flushCard_1 = flushCard; _h < flushCard_1.length; _h++) {
                                    var sc = flushCard_1[_h];
                                    sc.tag = 2;
                                }
                                break;
                            }
                            else if (flushCard.length === 4 && start === 2 && cards[0].cardNumber === 14) {
                                //处理 A 1 2 3 4 5 
                                flushCard.push(cards[0]);
                                for (var _j = 0, flushCard_2 = flushCard; _j < flushCard_2.length; _j++) {
                                    var sc = flushCard_2[_j];
                                    sc.tag = 2;
                                }
                                break;
                            }
                        }
                        for (var i = 0; i < cards.length; i++) {
                            if (cards[i].tag !== 2) {
                                cards[i].tag = 0;
                            }
                        }
                        break;
                    case HoldemPoker.msg.HandPowerTypes.FULL_HOUSE:
                        for (var i = 0; i < cards.length; i++) {
                            var hu = new Array;
                            hu.push(cards[i]);
                            for (var j = i + 1; j < cards.length; j++) {
                                if (cards[i].cardNumber === cards[j].cardNumber) {
                                    hu.push(cards[j]);
                                    if (hu.length === 3) {
                                        break;
                                    }
                                }
                            }
                            if (hu.length === 3) {
                                for (var _k = 0, hu_1 = hu; _k < hu_1.length; _k++) {
                                    var sc = hu_1[_k];
                                    sc.tag = 2;
                                }
                            }
                        }
                        for (var i = 0; i < cards.length; i++) {
                            var lu = new Array;
                            lu.push(cards[i]);
                            for (var j = i + 1; j < cards.length; j++) {
                                if (cards[i].cardNumber === cards[j].cardNumber) {
                                    lu.push(cards[j]);
                                    break;
                                }
                            }
                            if (lu.length === 2) {
                                for (var _l = 0, lu_1 = lu; _l < lu_1.length; _l++) {
                                    var sc = lu_1[_l];
                                    sc.tag = 2;
                                }
                            }
                        }
                        for (var i = 0; i < cards.length; i++) {
                            if (cards[i].tag !== 2) {
                                cards[i].tag = 0;
                            }
                        }
                        break;
                    case HoldemPoker.msg.HandPowerTypes.FOUR_OF_A_KIND:
                        for (var i = 0; i < cards.length; i++) {
                            var kind = new Array;
                            kind.push(cards[i]);
                            for (var j = i + 1; j < cards.length; j++) {
                                if (cards[i].cardNumber === cards[j].cardNumber) {
                                    kind.push(cards[j]);
                                    if (kind.length === 4) {
                                        break;
                                    }
                                }
                            }
                            if (kind.length === 4) {
                                for (var _m = 0, kind_1 = kind; _m < kind_1.length; _m++) {
                                    var sc = kind_1[_m];
                                    sc.tag = 2;
                                }
                            }
                        }
                        for (var i = 0; i < cards.length; i++) {
                            if (cards[i].tag !== 2) {
                                cards[i].tag = 0;
                            }
                        }
                        break;
                    case HoldemPoker.msg.HandPowerTypes.STRAIGHT_FLUSH:
                        flush = 0;
                        start = 0;
                        var hua = "";
                        for (var i = 0; i < cards.length; i++) {
                            flush = 0;
                            var flushCard = new Array;
                            flushCard.push(cards[i]);
                            start = cards[i].cardNumber;
                            hua = cards[i].cardSuit;
                            for (var j = i + 1; j < cards.length; j++) {
                                if (start - 1 === cards[j].cardNumber && hua === cards[j].cardSuit) {
                                    start = cards[j].cardNumber;
                                    flushCard.push(cards[j]);
                                    flush++;
                                    if (flush === 4) {
                                        break;
                                    }
                                }
                            }
                            if (flushCard.length === 5) {
                                for (var _o = 0, flushCard_3 = flushCard; _o < flushCard_3.length; _o++) {
                                    var sc = flushCard_3[_o];
                                    sc.tag = 2;
                                }
                                break;
                            }
                            else if (flushCard.length === 4 && start === 2 && cards[0].cardNumber === 14 && hua === cards[0].cardSuit) {
                                //处理 A 1 2 3 4 5 
                                flushCard.push(cards[0]);
                                for (var _p = 0, flushCard_4 = flushCard; _p < flushCard_4.length; _p++) {
                                    var sc = flushCard_4[_p];
                                    sc.tag = 2;
                                }
                                break;
                            }
                        }
                        for (var i = 0; i < cards.length; i++) {
                            if (cards[i].tag !== 2) {
                                cards[i].tag = 0;
                            }
                        }
                        break;
                    case HoldemPoker.msg.HandPowerTypes.ROYAL_STRAIGHT_FLUSH:
                        flush = 0;
                        start = 0;
                        hua = "";
                        for (var i = 0; i < cards.length; i++) {
                            flush = 0;
                            start = cards[i].cardNumber;
                            if (start === 14) {
                                var flushCard = new Array;
                                flushCard.push(cards[i]);
                                hua = cards[i].cardSuit;
                                for (var j = i + 1; j < cards.length; j++) {
                                    if (start - 1 === cards[j].cardNumber && hua === cards[j].cardSuit) {
                                        start = cards[j].cardNumber;
                                        flushCard.push(cards[j]);
                                        flush++;
                                        if (flush === 4) {
                                            break;
                                        }
                                    }
                                }
                                if (flushCard.length === 5) {
                                    for (var _q = 0, flushCard_5 = flushCard; _q < flushCard_5.length; _q++) {
                                        var sc = flushCard_5[_q];
                                        sc.tag = 2;
                                    }
                                    break;
                                }
                            }
                        }
                        for (var i = 0; i < cards.length; i++) {
                            if (cards[i].tag !== 2) {
                                cards[i].tag = 0;
                            }
                        }
                        break;
                    default:
                }
                this.setPubCards();
            };
            VFlop.prototype.cardSort = function (data1, data2) {
                if (data1.cardNumber > data2.cardNumber) {
                    return -1;
                }
                else if (data1.cardNumber < data2.cardNumber) {
                    return 1;
                }
                else {
                    return 0;
                }
            };
            //牌型提示
            VFlop.prototype.setPubCards = function () {
                var pubCard = this.vc.pubCard;
                ;
                for (var i = 0; i < pubCard.length; i++) {
                    var cardImg = this.vc.videoUI.boardCardGrp.getChildAt(i);
                    var pc = pubCard[i];
                    if (cardImg.visible) {
                        var big = cardImg.getChildAt(0);
                        if (pc.tag === 0) {
                            cardImg.filters = [HoldemPoker.Utility.grayFilter()];
                            big.skin = "1334/poker/card_shadow.png";
                        }
                        else if (pc.tag === 2) {
                            cardImg.filters = null;
                            big.skin = "1334/poker/pub_card_bg.png";
                        }
                        else {
                            cardImg.filters = null;
                        }
                    }
                }
            };
            VFlop.boardcardsPosition = [[48, 55], [48 + 84 * 1, 55], [48 + 84 * 2, 55], [48 + 84 * 3, 55], [48 + 84 * 4, 55]];
            return VFlop;
        }());
        HoldemPoker.VFlop = VFlop;
    })(HoldemPoker = wesai.HoldemPoker || (wesai.HoldemPoker = {}));
})(wesai || (wesai = {}));
//# sourceMappingURL=VFlop.js.map