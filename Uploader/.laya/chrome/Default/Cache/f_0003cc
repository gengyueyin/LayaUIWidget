var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var wesai;
(function (wesai) {
    var HoldemPoker;
    (function (HoldemPoker) {
        /**
         *
         *
         * @export
         * @class RoundResultState
         * @implements {State}
         */
        var RoundResultState = /** @class */ (function (_super) {
            __extends(RoundResultState, _super);
            function RoundResultState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            RoundResultState.prototype.onState = function (from) {
                _super.prototype.onState.call(this, from);
                this.process();
            };
            //根据玩家ID 获取玩家增益信息 可以用来获取sitid 跟 玩家ID 所对应的面板
            RoundResultState.prototype.getSitIdinGainsByPlayerID = function (playerID, gains) {
                for (var _i = 0, gains_1 = gains; _i < gains_1.length; _i++) {
                    var gain = gains_1[_i];
                    if (playerID === gain.playerId) {
                        return gain;
                    }
                }
                return null;
            };
            RoundResultState.prototype.getSitIdinGainsBySitID = function (sitId, gains) {
                for (var _i = 0, gains_2 = gains; _i < gains_2.length; _i++) {
                    var gain = gains_2[_i];
                    if (sitId === gain.sitId) {
                        return gain;
                    }
                }
                return null;
            };
            //获取获胜玩家的gains信息
            RoundResultState.prototype.getWinnerGainsInfo = function (winnerId, gains) {
                for (var _i = 0, gains_3 = gains; _i < gains_3.length; _i++) {
                    var player = gains_3[_i];
                    if (winnerId === player.playerId) {
                        return player;
                    }
                }
                return null;
            };
            RoundResultState.prototype.process = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var roomControl, gameData, mainPot, i, i_1, winnerId, winPlayer, winnerPanel, seatData, _i, _a, gains, playerGains, _b, _c, pot, _d, _e, playerId, gainInfo, panel, seat;
                    return __generator(this, function (_f) {
                        switch (_f.label) {
                            case 0:
                                roomControl = this.fsm.rc;
                                roomControl.showCardRequest(); //执行亮牌请求
                                gameData = roomControl.roomData.gameData;
                                roomControl.gameUI.hiddenOperationButton();
                                return [4 /*yield*/, roomControl.gameUI.asyncCollectBetAnimation()];
                            case 1:
                                _f.sent();
                                roomControl.gameUI.updateRoundPot(gameData.pot);
                                //更新 showdown玩家的显示包括发牌形  和 牌形展示
                                roomControl.gameUI.playerShowDownCardTypes();
                                mainPot = null;
                                for (i = 0; i < gameData.sidePots.length; i++) {
                                    if (gameData.sidePots[i].potType === 1) {
                                        mainPot = gameData.sidePots[i];
                                        break;
                                    }
                                }
                                if (!mainPot) return [3 /*break*/, 3];
                                //更新底池 就是编号为0池信息就是底池的值
                                roomControl.gameUI.updatePot(mainPot.gold);
                                //显示获胜动画
                                for (i_1 = 0; i_1 < mainPot.winnerId.length; i_1++) {
                                    winnerId = mainPot.winnerId[i_1];
                                    winPlayer = this.getWinnerGainsInfo(winnerId, gameData.gainsPlayerInfos);
                                    winnerPanel = roomControl.gameUI.getSeatByServerPos(winPlayer.sitId);
                                    seatData = roomControl.roomData.getSeatByPlayerId(winnerId);
                                    //在赢的玩家上显示winner 其他人不管
                                    if (winnerPanel) {
                                        winnerPanel.clearStatus(true);
                                        winnerPanel.ani_win.play(0, false);
                                    }
                                    //是自己 就播放赢牌的动画
                                    if (HoldemPoker.Sys.players.self.isSelf(winnerId)) {
                                        // roomControl.gameUI.updateWinnerUI(true);
                                        for (_i = 0, _a = roomControl.roomData.gameData.gainsPlayerInfos; _i < _a.length; _i++) {
                                            gains = _a[_i];
                                            if (gains.playerId === winnerId) {
                                                if (gains.handCard) {
                                                    roomControl.gameUI.asyncSelfPlayerWinner(winPlayer.handPower.handPowerEnum.handPowerTypes);
                                                }
                                                else {
                                                    roomControl.gameUI.asyncSelfPlayerWinner(null);
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                                playerGains = this.getPlayerGains();
                                return [4 /*yield*/, this.asyncPlayerGainsGrpAni(playerGains, roomControl.gameUI)];
                            case 2:
                                _f.sent();
                                _f.label = 3;
                            case 3:
                                // 更新筹码
                                for (_b = 0, _c = gameData.sidePots; _b < _c.length; _b++) {
                                    pot = _c[_b];
                                    for (_d = 0, _e = pot.playerIds; _d < _e.length; _d++) {
                                        playerId = _e[_d];
                                        gainInfo = this.getSitIdinGainsByPlayerID(playerId, gameData.gainsPlayerInfos);
                                        panel = roomControl.gameUI.getSeatByPlayerId(playerId);
                                        seat = roomControl.roomData.getSeatByPlayerId(playerId);
                                        if (panel && gainInfo && seat) {
                                            console.log("更新筹码：" + playerId + ":" + gainInfo.bankroll);
                                            seat.bankroll = gainInfo.bankroll;
                                            panel.updateChipText(gainInfo.bankroll);
                                        }
                                    }
                                }
                                roomControl.roomData.canSitDown = roomControl.roomData.waitHands > 0; //开始不能坐下
                                return [4 /*yield*/, HoldemPoker.Utility.waitForSeconds(2000)];
                            case 4:
                                _f.sent();
                                roomControl.gameUI.insuranceViewUI.visible = false;
                                roomControl.roomData.newRound();
                                roomControl.gameUI.restartGame();
                                // roomControl.roomData.lastdelarPos = roomControl.roomData.getDelarSitID();
                                roomControl.roomData.lastdelarPos = roomControl.roomData.dealerSeatId;
                                //console.debug(`this round delar sitid is ${roomControl.roomData.lastdelarPos}`);
                                //roomControl.gameUI.hideBoardCards();
                                //roomControl.gameUI.updateMadeHands();
                                return [4 /*yield*/, roomControl.gameUI.actionRoundStartStateAni()];
                            case 5:
                                //console.debug(`this round delar sitid is ${roomControl.roomData.lastdelarPos}`);
                                //roomControl.gameUI.hideBoardCards();
                                //roomControl.gameUI.updateMadeHands();
                                _f.sent();
                                roomControl.go(HoldemPoker.PlayState.WaitingState);
                                return [2 /*return*/];
                        }
                    });
                });
            };
            RoundResultState.prototype.wait2 = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2 /*return*/, new Promise(function (resolve) {
                                setTimeout(resolve, 2000);
                            })];
                    });
                });
            };
            //获取分池中 玩家的gains消息 返会列表 
            RoundResultState.prototype.getPlayerGains = function () {
                var roomControl = this.fsm.rc;
                var gameData = roomControl.roomData.gameData;
                var playerGains = [];
                //遍历整个sidepot表 然后根据获胜者的id 获取增加的数值
                for (var _i = 0, _a = gameData.sidePots; _i < _a.length; _i++) {
                    var sidPots = _a[_i];
                    for (var i = 0; i < sidPots.winnerId.length; i++) {
                        var gain = this.getGainsNumByPlayerId(sidPots.winnerId[i]);
                        var gainsinfo = this.getWinnerGainsInfo(sidPots.winnerId[i], roomControl.roomData.gameData.gainsPlayerInfos);
                        var gains = {
                            playerId: sidPots.winnerId[i],
                            gold: gain,
                            handPower: gainsinfo.handPower
                        };
                        if (this.indexOfPlayerGains(playerGains, sidPots.winnerId[i]) !== 1) {
                            playerGains.push(gains);
                        }
                    }
                }
                playerGains.sort(this.sortByHandPower);
                return playerGains;
            };
            RoundResultState.prototype.indexOfPlayerGains = function (playerGains, playerId) {
                for (var _i = 0, playerGains_1 = playerGains; _i < playerGains_1.length; _i++) {
                    var gains = playerGains_1[_i];
                    if (gains.playerId === playerId) {
                        return 1;
                    }
                }
                return -1;
            };
            RoundResultState.prototype.asyncPlayerGainsGrpAni = function (gains, end) {
                return __awaiter(this, void 0, void 0, function () {
                    var promiseAll, _i, gains_4, winner, panel, roomControl, gameData, panels, allGains, _a, _b, player, panel;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                promiseAll = [];
                                _i = 0, gains_4 = gains;
                                _c.label = 1;
                            case 1:
                                if (!(_i < gains_4.length)) return [3 /*break*/, 4];
                                winner = gains_4[_i];
                                panel = end.getSeatByPlayerId(winner.playerId);
                                if (!panel) return [3 /*break*/, 3];
                                return [4 /*yield*/, this.asyncResultsGainsAni(panel, winner.gold, end)];
                            case 2:
                                _c.sent();
                                _c.label = 3;
                            case 3:
                                _i++;
                                return [3 /*break*/, 1];
                            case 4:
                                roomControl = this.fsm.rc;
                                gameData = roomControl.roomData.gameData;
                                panels = [];
                                allGains = [];
                                for (_a = 0, _b = gameData.gainsPlayerInfos; _a < _b.length; _a++) {
                                    player = _b[_a];
                                    panel = roomControl.gameUI.getSeatByPlayerId(player.playerId);
                                    panels.push(panel);
                                    allGains.push(player.gains);
                                }
                                return [4 /*yield*/, HoldemPoker.UIAnimator.resultGainNumPictureAin(panels, allGains)];
                            case 5:
                                _c.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            RoundResultState.prototype.getGainsNumByPlayerId = function (playerId) {
                var roomControl = this.fsm.rc;
                var gameData = roomControl.roomData.gameData;
                var gains = 0;
                //遍历边池表 然后获取winneid 将gains的数据加起来 放到
                for (var i = 0; i < gameData.sidePots.length; i++) {
                    for (var j = 0; j < gameData.sidePots[i].winnerId.length; j++) {
                        if (gameData.sidePots[i].winnerId[j] === playerId) {
                            var g = gameData.sidePots[i].gold / gameData.sidePots[i].winnerId.length;
                            //如果有小数，打日志
                            if (g - Math.floor(g) > 0) {
                                console.debug("GAIN: pot=" + gameData.sidePots[i].gold + " winner=" + gameData.sidePots[i].winnerId.length);
                            }
                            gains += Math.floor(g);
                            break;
                        }
                    }
                }
                //获取 winnerid 的gains info 
                // let playerGain: msg.PlayerGainsInfo = this.getWinnerGainsInfo(playerId, roomControl.roomData.gameData.gainsPlayerInfos);
                // let seat = roomControl.roomData.getSeatByPlayerId(playerId);
                // if (seat) {
                //     //增加的数值 减去之前的值 得到的就是 实际增加的数值
                //     gains = playerGain.bankroll - seat.bankroll;
                // }
                return gains;
            };
            RoundResultState.prototype.sortByHandPower = function (data1, data2) {
                if (data1.handPower.handPowerEnum.handPowerTypes > data2.handPower.handPowerEnum.handPowerTypes) {
                    return -1;
                }
                else if (data1.handPower.handPowerEnum.handPowerTypes < data2.handPower.handPowerEnum.handPowerTypes) {
                    return 1;
                }
                else if (data1.handPower.handPowerEnum.handPowerTypes === data2.handPower.handPowerEnum.handPowerTypes) {
                    return 0;
                }
            };
            RoundResultState.prototype.asyncResultsGainsAni = function (target, gain, end) {
                return __awaiter(this, void 0, void 0, function () {
                    var roomControl, seat;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, HoldemPoker.UIAnimator.asyncResultsGainsChipAni(target, end)];
                            case 1:
                                _a.sent();
                                roomControl = this.fsm.rc;
                                seat = roomControl.roomData.getSeatBySitId(target.serverPos);
                                if (seat) {
                                    seat.bankroll += gain;
                                    target.updateChipText(seat.bankroll);
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
            //增长筹码的动画  将 所有获胜的玩家只飞一次 计算增加的筹码只飞一次 顺序是由 牌型最大的人开始飞 然后飞 剩下的 。增加负数的收益
            RoundResultState.prototype.asyncResultsGainsGrpAni = function (pot, end) {
                var promiseAll = [];
                for (var _i = 0, _a = pot.winnerId; _i < _a.length; _i++) {
                    var winner = _a[_i];
                    var panel = end.getSeatByPlayerId(winner);
                    if (panel) {
                        var gain = pot.gold / pot.winnerId.length;
                        if (gain - Math.floor(gain) > 0) {
                            console.debug("GAIN: pot=" + pot.gold + " winner=" + pot.winnerId.length);
                        }
                        promiseAll.push(this.asyncResultsGainsAni(panel, Math.floor(gain), end));
                    }
                }
                ;
                return Promise.all(promiseAll);
            };
            return RoundResultState;
        }(HoldemPoker.BaseState));
        HoldemPoker.RoundResultState = RoundResultState;
    })(HoldemPoker = wesai.HoldemPoker || (wesai.HoldemPoker = {}));
})(wesai || (wesai = {}));
//# sourceMappingURL=RoundResultState.js.map